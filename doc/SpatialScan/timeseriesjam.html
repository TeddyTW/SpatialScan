<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>SpatialScan.timeseriesjam API documentation</title>
<meta name="description" content="Module containing Time Series Forecast functionality for JamCam data" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SpatialScan.timeseriesjam</code></h1>
</header>
<section id="section-intro">
<p>Module containing Time Series Forecast functionality for JamCam data</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module containing Time Series Forecast functionality for JamCam data&#34;&#34;&#34;
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
from scipy.optimize import minimize
import gpflow
from gpflow.utilities import print_summary


def holt_wintersJ(
    df: pd.DataFrame,
    days_in_past: int,
    days_in_future: int,
    alpha: float = 0.05,
    beta: float = 0.05,
    gamma: float = 0.4,
    display: bool = False,
    detectors: list = None,
) -&gt; pd.DataFrame:

    &#34;&#34;&#34;Average forecast using Holt-Winters method for JamCam 16h cycles

    Args: 
        df: Dataframe of JamCam data
        detectors: List of detectors to look at
        days_in_past: Integer number of previous days to use for forecast
        days_in_future: Days in future produce a for forecast for
        display: boolean which determines whether to plot forecast
        alpha, beta, gamma: optimisation parameters

    Returns:
        Dataframe forecast in same format as JamCam input dataframe

        &#34;&#34;&#34;

    if detectors is None:
        detectors = df[&#34;detector_id&#34;].drop_duplicates().to_numpy()

    framelist = []
    for detector in detectors:
        S = 1
        T = 1
        I = np.ones(16)
        one_D = df[df[&#34;detector_id&#34;] == detector]
        one_D = one_D.sort_values(by=[&#34;measurement_end_utc&#34;])
        past = one_D.tail(n=16 * days_in_past)
        for i in range(0, len(past)):
            h = i % 16
            c = past[&#34;n_vehicles_in_interval&#34;].iloc[i]
            Snew = (alpha * (c / I[h])) + (1 - alpha) * (S + T)
            T = beta * (Snew - S) + (1 - beta) * T
            I[h] = gamma * (c / Snew) + (1 - gamma) * I[h]
            S = Snew

        baseline = []
        endtime = []
        starttime = []
        shift = 1
        for j in range(0, days_in_future * 16):
            h = j % 16
            if h == 0:
                shift += 8
            end = df[&#34;measurement_end_utc&#34;].to_numpy()[-1] + np.timedelta64(
                j + shift, &#34;h&#34;
            )
            start = df[&#34;measurement_start_utc&#34;].to_numpy()[-1] + np.timedelta64(
                j + shift, &#34;h&#34;
            )

            b = (S + T) * I[h]
            baseline.append(b)
            endtime.append(end)
            starttime.append(start)

            Snew = (alpha * (b / I[h])) + (1 - alpha) * (S + T)
            T = beta * (Snew - S) + (1 - beta) * T
            I[h] = gamma * (b / Snew) + (1 - gamma) * I[h]
            S = Snew

        df2 = pd.DataFrame(
            {
                &#34;detector_id&#34;: detector,
                &#34;lon&#34;: one_D[one_D[&#34;detector_id&#34;] == detector][&#34;lon&#34;].iloc[0],
                &#34;lat&#34;: one_D[one_D[&#34;detector_id&#34;] == detector][&#34;lat&#34;].iloc[0],
                &#34;measurement_start_utc&#34;: starttime,
                &#34;measurement_end_utc&#34;: endtime,
                &#34;n_vehicles_in_interval&#34;: baseline,
            }
        )
        framelist.append(df2)
    DF = pd.concat(framelist)

    if display:
        df_plot = DF.set_index(&#34;measurement_end_utc&#34;)
        for detector in detectors:
            df_plot[df_plot[&#34;detector_id&#34;] == detector][&#34;n_vehicles_in_interval&#34;].plot()

    return DF


def count_baselineJ(
    df: pd.DataFrame,
    days_in_past: int,
    days_in_future: int,
    method: str = &#34;HW&#34;,
    detectors: list = None,
    alpha: float = 0.1,
    beta: float = 0.1,
    gamma: float = 0.2,
    kern = None
) -&gt; pd.DataFrame:

    &#34;&#34;&#34;Produces a DataFrame where the count and baseline can be compared for use
        in scan statistics

    Args:
        df: Dataframe of JamCam data
        days_in_past: Integer past days to train forecast one
        days_in_future: Days in future produce a baseline too and record count for
        method: Forecast method to use for baseline, default is &#34;HW&#34; for Holt-Winters, option for GP
        detectors: List of detectors to look at

    Returns:
        Dataframe of counts and baseline along with detector data

        &#34;&#34;&#34;

    t_min = df[&#34;measurement_start_utc&#34;].min()
    t_max = df[&#34;measurement_end_utc&#34;].max()

    print(&#34;Input dataframe contains data spanning {} to {}.&#34;.format(t_min, t_max))

    if detectors is None:
        detectors = df[&#34;detector_id&#34;].drop_duplicates().to_numpy()

    prediction_start = df[&#34;measurement_end_utc&#34;].iloc[-1] - np.timedelta64(
        days_in_future * 24, &#34;h&#34;
    )

    train_data = df[df[&#34;measurement_end_utc&#34;] &lt;= prediction_start]
    test_data = df[df[&#34;measurement_end_utc&#34;] &gt; prediction_start]

    avail_past_days = int(len(train_data[&#34;measurement_end_utc&#34;].unique()) / 16)
    if avail_past_days &lt; days_in_past:
        print(
            &#34;Input dataframe only contains {} days worth of data before the prediction period.&#34;.format(
                avail_past_days
            ),
            &#34;Setting days_in_past = {}.&#34;.format(avail_past_days),
        )

    print(
        &#34;Using data from {} to {}, to forecast counts between {} and {} for {} detectors using {} method...&#34;.format(
            t_min, prediction_start, prediction_start, t_max, len(detectors), method
        )
    )

    if method == &#34;HW&#34;:
        y = holt_wintersJ(
            train_data,
            days_in_past,
            days_in_future,
            alpha=alpha,
            beta=beta,
            gamma=gamma,
            detectors=detectors,
        )

    if method == &#34;GP&#34;:
        y = GP_forecast(
            train_data,
            days_in_past=days_in_past,
            days_in_future=days_in_future,
            detectors=detectors,
            kern = kern,
        )

    sd = []

    print(&#34;Forecasting complete.&#34;)

    for detector in detectors:

        sd.append(test_data[test_data[&#34;detector_id&#34;] == detector])

    sample_test_data = pd.concat(sd)

    Y = y.merge(
        sample_test_data,
        on=[
            &#34;lon&#34;,
            &#34;lat&#34;,
            &#34;measurement_end_utc&#34;,
            &#34;detector_id&#34;,
            &#34;measurement_start_utc&#34;,
        ],
        how=&#34;left&#34;,
    )
    Y = Y.rename(
        columns={
            &#34;n_vehicles_in_interval_x&#34;: &#34;baseline&#34;,
            &#34;n_vehicles_in_interval_y&#34;: &#34;count&#34;,
        }
    )

    # T = pd.date_range(
    #     start=Y[&#34;measurement_end_utc&#34;].min() - np.timedelta64(3, &#34;h&#34;),
    #     end=Y[&#34;measurement_end_utc&#34;].max() + np.timedelta64(5, &#34;h&#34;),
    #     freq=&#34;H&#34;,
    # )
    # dets = Y[&#34;detector_id&#34;].unique()
    # mux = pd.MultiIndex.from_product(
    #     [dets, T], names=(&#34;detector_id&#34;, &#34;measurement_end_utc&#34;)
    # )
    # Y = Y.set_index([&#34;detector_id&#34;, &#34;measurement_end_utc&#34;])
    # Y = Y.reindex(mux)

    # Y = Y.reset_index()

    return Y


def CB_plotJ(df: pd.DataFrame):

    &#34;&#34;&#34;Function that plots Counts/Baseline as a 3D plot  with detector locations. Counts are 
        shown by size of point, and C/B is shown using a colourmap
        
        Args:
            Dataframe with Time, Count and Baseline columns
            &#34;&#34;&#34;

    df_format = df

    forecast_t_min = df_format[&#34;measurement_start_utc&#34;].min()
    forecast_t_max = df_format[&#34;measurement_end_utc&#34;].max()

    df_format[&#34;C/B&#34;] = df_format[&#34;count&#34;] / df_format[&#34;baseline&#34;]
    df_format[&#34;hour_from_start&#34;] = (
        df_format[&#34;measurement_end_utc&#34;] - df_format[&#34;measurement_end_utc&#34;].min()
    )
    df_format[&#34;hour_from_start&#34;] = df_format[&#34;hour_from_start&#34;].astype(
        dtype=&#34;timedelta64[h]&#34;
    )
    offset = colors.TwoSlopeNorm(vmin=0.5, vcenter=1, vmax=2)
    fig = plt.figure(figsize=(20, 10))
    ax = fig.add_subplot(111, projection=&#34;3d&#34;)
    p = ax.scatter(
        df_format[&#34;lon&#34;],
        df_format[&#34;lat&#34;],
        df_format[&#34;hour_from_start&#34;],
        c=df_format[&#34;C/B&#34;],
        s=df_format[&#34;count&#34;] * 0.1,
        norm=offset,
        cmap=&#34;coolwarm&#34;,
    )
    ax.set_xlabel(&#34;lon&#34;)
    ax.set_ylabel(&#34;lat&#34;)
    ax.set_zlabel(&#34;Hours&#34;)
    fig.colorbar(p)
    fig.suptitle(&#34;Forecast from {} to {}&#34;.format(forecast_t_min, forecast_t_max))
    plt.show()


def GP_forecast_gaps(
    df: pd.DataFrame,
    days_in_past: int = 2,
    days_in_future: int = 1,
    detectors: list = None,
) -&gt; pd.DataFrame:

    &#34;&#34;&#34;Forecast using Gaussian Processes 
    Args: 
        df: Dataframe of JamCam data
        days_in_past: Integer number of previous days to use for forecast
        days_in_future: Days in future produce a for forecast for
        detectors: List of detectors to look at


    Returns:
        Dataframe forecast in same format as JamCam input dataframe

        &#34;&#34;&#34;

    # extract numpy array of detector ID&#39;s
    if detectors is None:
        detectors = df[&#34;detector_id&#34;].drop_duplicates().to_numpy()
    framelist = []

    i = 0
    for detector in detectors:
        i += 1

        dataset = df[df[&#34;detector_id&#34;] == detector].tail(n=16 * days_in_past)

        Y = dataset[&#34;n_vehicles_in_interval&#34;].to_numpy().reshape(-1, 1)
        Y = Y.astype(float)
        X = np.arange(1, len(Y) + 1, dtype=float).reshape(-1, 1)

        scaler = MinMaxScaler(feature_range=(-1, 1))
        y = scaler.fit_transform(Y)

        kern_pD = gpflow.kernels.Periodic(gpflow.kernels.SquaredExponential())
        kern_pW = gpflow.kernels.Periodic(gpflow.kernels.SquaredExponential())
        kern_SE = gpflow.kernels.SquaredExponential()
        kern_W = gpflow.kernels.White()
        # kern_M = gpflow.kernels.Matern52()

        kern_pD.period.assign(16.0)
        # kern_pD.base_kernel.variance.assign(10)
        kern_pW.period.assign(112.0)
        # kern_pW.base_kernel.variance.assign(10)

        k = kern_pD * kern_pW + kern_SE + kern_W

        m = gpflow.models.GPR(data=(X, y), kernel=k, mean_function=None)
        opt = gpflow.optimizers.Scipy()
        opt_logs = opt.minimize(
            m.training_loss, m.trainable_variables, options=dict(maxiter=100)
        )

        print(&#34;please wait: &#34;, i, &#34;/&#34;, len(detectors), end=&#34;\r&#34;)

        ## generate test points for prediction
        xx = np.linspace(
            len(Y) + 1, len(Y) + (days_in_future * 16) + 1, (days_in_future * 16)
        ).reshape(
            (days_in_future * 16), 1
        )  # test points must be of shape (N, D)

        ## predict mean and variance of latent GP at test points
        mean, var = m.predict_f(xx)

        # reverse min_max scaler
        testPredict = scaler.inverse_transform(mean)
        testVar = scaler.inverse_transform(var)

        # find the time period for our testPredictions
        start_date = dataset[&#34;measurement_end_utc&#34;].max() + np.timedelta64(8, &#34;h&#34;)
        end_date = (start_date + np.timedelta64(16 + (24 * (days_in_future - 1)), &#34;h&#34;),)

        # print(start_date, end_date)
        N_days = days_in_future
        T = pd.date_range(start=start_date, periods=16, freq=&#34;H&#34;)
        start_of_day = start_date + np.timedelta64(1, &#34;D&#34;)
        for d in range(0, N_days - 1):
            t = pd.date_range(
                start=start_of_day, end=start_of_day + np.timedelta64(15, &#34;h&#34;), freq=&#34;H&#34;
            ).to_numpy()

            T = np.append(T, t)
            start_of_day = start_of_day + np.timedelta64(1, &#34;D&#34;)

        T = np.array(T)

        # organise data into dataframe similar to the SCOOT outputs
        df2 = pd.DataFrame(
            {
                &#34;detector_id&#34;: detector,
                &#34;lon&#34;: df[df[&#34;detector_id&#34;] == detector][&#34;lon&#34;].iloc[0],
                &#34;lat&#34;: df[df[&#34;detector_id&#34;] == detector][&#34;lat&#34;].iloc[0],
                &#34;measurement_start_utc&#34;: T,
                &#34;measurement_end_utc&#34;: T + np.timedelta64(1, &#34;h&#34;),
                &#34;n_vehicles_in_interval&#34;: testPredict.flatten(),
                &#34;prediction_variance&#34;: testVar.flatten(),
            }
        )

        framelist.append(df2)

    return pd.concat(framelist)

def forecast_plotJ(df: pd.DataFrame, detector: str = None):
    &#34;&#34;&#34;Function that plots the Count against the forecasted Baseline
        
        Args:
            df: Dataframe with Time, Count and Baseline columns
            detector: String of detector name, if none detector chosen at random&#34;&#34;&#34;

    detectors = df[&#34;detector_id&#34;].drop_duplicates()
    if detector is None:
        detector = detectors.sample(n=1).to_numpy()[0]

    df_d = df[df[&#34;detector_id&#34;] == detector]
    print(detector)
    df_d = df_d.sort_values(&#34;measurement_end_utc&#34;)
    ax=df_d.plot(x=&#34;measurement_end_utc&#34;, y=[&#34;baseline&#34;, &#34;count&#34;])
    if &#34;prediction_variance&#34; in df_d.columns:
        plt.fill_between(
            df_d[&#34;measurement_end_utc&#34;],
            df_d[&#34;baseline&#34;] + 2*np.sqrt(df_d[&#34;prediction_variance&#34;]),
            df_d[&#34;baseline&#34;] - 2*np.sqrt(df_d[&#34;prediction_variance&#34;]),
            color=&#34;C0&#34;,
            alpha=0.5, label= &#34;2$\sigma$&#34;)
    plt.legend()


def GP_forecast(
    df: pd.DataFrame,
    days_in_past: int = 2,
    days_in_future: int = 1,
    detectors: list = None,
    kern = None
) -&gt; pd.DataFrame:

    &#34;&#34;&#34;Forecast using Gaussian Processes 
    Args: 
        df: Dataframe of JamCam data
        days_in_past: Integer number of previous days to use for forecast
        days_in_future: Days in future produce a for forecast for
        detectors: List of detectors to look at


    Returns:
        Dataframe forecast in same format as JamCam input dataframe

        &#34;&#34;&#34;

    # extract numpy array of detector ID&#39;s
    if detectors is None:
        detectors = df[&#34;detector_id&#34;].drop_duplicates().to_numpy()
    framelist = []

    i = 0
    for detector in detectors:
        i += 1

        dataset = df[df[&#34;detector_id&#34;] == detector].tail(n=26* days_in_past)

        Y = dataset[&#34;n_vehicles_in_interval&#34;].to_numpy().reshape(-1, 1)
        Y = Y.astype(float)
        X = (dataset[&#34;measurement_end_utc&#34;]-dataset[&#34;measurement_end_utc&#34;].min()).astype(&#34;timedelta64[h]&#34;).to_numpy().reshape(-1, 1)

        scaler = MinMaxScaler(feature_range=(-1, 1))
        y = scaler.fit_transform(Y)

        if(kern is None):

            kern_pD = gpflow.kernels.Periodic(gpflow.kernels.SquaredExponential())
            kern_pW = gpflow.kernels.Periodic(gpflow.kernels.SquaredExponential())
            kern_SE = gpflow.kernels.SquaredExponential()
            kern_W = gpflow.kernels.White()
            kern_M = gpflow.kernels.Matern32()

            kern_pD.period.assign(24.0)
            # kern_pD.base_kernel.variance.assign(10)
            kern_pW.period.assign(168.0)
            # kern_pW.base_kernel.variance.assign(10)

            k = kern_pD + kern_M
        else:
            k=kern

        m = gpflow.models.GPR(data=(X, y), kernel=k, mean_function=None)
        opt = gpflow.optimizers.Scipy()
        opt_logs = opt.minimize(
            m.training_loss, m.trainable_variables, options=dict(maxiter=100)
        )

        print(&#34;please wait: &#34;, i, &#34;/&#34;, len(detectors), end=&#34;\r&#34;)

        ## generate test points for prediction
        xx = np.linspace(
            X.max() + 1, X.max() + (days_in_future * 24) + 1, (days_in_future * 24)
        ).reshape(
            (days_in_future * 24), 1
        )  # test points must be of shape (N, D)

        ## predict mean and variance of latent GP at test points
        mean, var = m.predict_f(xx)

        # reverse min_max scaler
        testPredict = scaler.inverse_transform(mean)
        testVar = scaler.inverse_transform(var)

        # find the time period for our testPredictions
        start_date = dataset[&#34;measurement_end_utc&#34;].max()
        end_date = start_date + np.timedelta64(24 * (days_in_future) -1, &#34;h&#34;)

        T = pd.date_range(start_date, end_date, freq=&#34;H&#34;)

        # organise data into dataframe similar to the SCOOT outputs
        df2 = pd.DataFrame(
            {
                &#34;detector_id&#34;: detector,
                &#34;lon&#34;: df[df[&#34;detector_id&#34;] == detector][&#34;lon&#34;].iloc[0],
                &#34;lat&#34;: df[df[&#34;detector_id&#34;] == detector][&#34;lat&#34;].iloc[0],
                &#34;measurement_start_utc&#34;: T,
                &#34;measurement_end_utc&#34;: T + np.timedelta64(1, &#34;h&#34;),
                &#34;n_vehicles_in_interval&#34;: testPredict.flatten(),
                &#34;prediction_variance&#34;: testVar.flatten(),
            }
        )

        framelist.append(df2)

    return pd.concat(framelist)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="SpatialScan.timeseriesjam.CB_plotJ"><code class="name flex">
<span>def <span class="ident">CB_plotJ</span></span>(<span>df: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that plots Counts/Baseline as a 3D plot
with detector locations. Counts are
shown by size of point, and C/B is shown using a colourmap</p>
<h2 id="args">Args</h2>
<p>Dataframe with Time, Count and Baseline columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CB_plotJ(df: pd.DataFrame):

    &#34;&#34;&#34;Function that plots Counts/Baseline as a 3D plot  with detector locations. Counts are 
        shown by size of point, and C/B is shown using a colourmap
        
        Args:
            Dataframe with Time, Count and Baseline columns
            &#34;&#34;&#34;

    df_format = df

    forecast_t_min = df_format[&#34;measurement_start_utc&#34;].min()
    forecast_t_max = df_format[&#34;measurement_end_utc&#34;].max()

    df_format[&#34;C/B&#34;] = df_format[&#34;count&#34;] / df_format[&#34;baseline&#34;]
    df_format[&#34;hour_from_start&#34;] = (
        df_format[&#34;measurement_end_utc&#34;] - df_format[&#34;measurement_end_utc&#34;].min()
    )
    df_format[&#34;hour_from_start&#34;] = df_format[&#34;hour_from_start&#34;].astype(
        dtype=&#34;timedelta64[h]&#34;
    )
    offset = colors.TwoSlopeNorm(vmin=0.5, vcenter=1, vmax=2)
    fig = plt.figure(figsize=(20, 10))
    ax = fig.add_subplot(111, projection=&#34;3d&#34;)
    p = ax.scatter(
        df_format[&#34;lon&#34;],
        df_format[&#34;lat&#34;],
        df_format[&#34;hour_from_start&#34;],
        c=df_format[&#34;C/B&#34;],
        s=df_format[&#34;count&#34;] * 0.1,
        norm=offset,
        cmap=&#34;coolwarm&#34;,
    )
    ax.set_xlabel(&#34;lon&#34;)
    ax.set_ylabel(&#34;lat&#34;)
    ax.set_zlabel(&#34;Hours&#34;)
    fig.colorbar(p)
    fig.suptitle(&#34;Forecast from {} to {}&#34;.format(forecast_t_min, forecast_t_max))
    plt.show()</code></pre>
</details>
</dd>
<dt id="SpatialScan.timeseriesjam.GP_forecast"><code class="name flex">
<span>def <span class="ident">GP_forecast</span></span>(<span>df: pandas.core.frame.DataFrame, days_in_past: int = 2, days_in_future: int = 1, detectors: list = None, kern=None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Forecast using Gaussian Processes
Args:
df: Dataframe of JamCam data
days_in_past: Integer number of previous days to use for forecast
days_in_future: Days in future produce a for forecast for
detectors: List of detectors to look at</p>
<h2 id="returns">Returns</h2>
<p>Dataframe forecast in same format as JamCam input dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GP_forecast(
    df: pd.DataFrame,
    days_in_past: int = 2,
    days_in_future: int = 1,
    detectors: list = None,
    kern = None
) -&gt; pd.DataFrame:

    &#34;&#34;&#34;Forecast using Gaussian Processes 
    Args: 
        df: Dataframe of JamCam data
        days_in_past: Integer number of previous days to use for forecast
        days_in_future: Days in future produce a for forecast for
        detectors: List of detectors to look at


    Returns:
        Dataframe forecast in same format as JamCam input dataframe

        &#34;&#34;&#34;

    # extract numpy array of detector ID&#39;s
    if detectors is None:
        detectors = df[&#34;detector_id&#34;].drop_duplicates().to_numpy()
    framelist = []

    i = 0
    for detector in detectors:
        i += 1

        dataset = df[df[&#34;detector_id&#34;] == detector].tail(n=26* days_in_past)

        Y = dataset[&#34;n_vehicles_in_interval&#34;].to_numpy().reshape(-1, 1)
        Y = Y.astype(float)
        X = (dataset[&#34;measurement_end_utc&#34;]-dataset[&#34;measurement_end_utc&#34;].min()).astype(&#34;timedelta64[h]&#34;).to_numpy().reshape(-1, 1)

        scaler = MinMaxScaler(feature_range=(-1, 1))
        y = scaler.fit_transform(Y)

        if(kern is None):

            kern_pD = gpflow.kernels.Periodic(gpflow.kernels.SquaredExponential())
            kern_pW = gpflow.kernels.Periodic(gpflow.kernels.SquaredExponential())
            kern_SE = gpflow.kernels.SquaredExponential()
            kern_W = gpflow.kernels.White()
            kern_M = gpflow.kernels.Matern32()

            kern_pD.period.assign(24.0)
            # kern_pD.base_kernel.variance.assign(10)
            kern_pW.period.assign(168.0)
            # kern_pW.base_kernel.variance.assign(10)

            k = kern_pD + kern_M
        else:
            k=kern

        m = gpflow.models.GPR(data=(X, y), kernel=k, mean_function=None)
        opt = gpflow.optimizers.Scipy()
        opt_logs = opt.minimize(
            m.training_loss, m.trainable_variables, options=dict(maxiter=100)
        )

        print(&#34;please wait: &#34;, i, &#34;/&#34;, len(detectors), end=&#34;\r&#34;)

        ## generate test points for prediction
        xx = np.linspace(
            X.max() + 1, X.max() + (days_in_future * 24) + 1, (days_in_future * 24)
        ).reshape(
            (days_in_future * 24), 1
        )  # test points must be of shape (N, D)

        ## predict mean and variance of latent GP at test points
        mean, var = m.predict_f(xx)

        # reverse min_max scaler
        testPredict = scaler.inverse_transform(mean)
        testVar = scaler.inverse_transform(var)

        # find the time period for our testPredictions
        start_date = dataset[&#34;measurement_end_utc&#34;].max()
        end_date = start_date + np.timedelta64(24 * (days_in_future) -1, &#34;h&#34;)

        T = pd.date_range(start_date, end_date, freq=&#34;H&#34;)

        # organise data into dataframe similar to the SCOOT outputs
        df2 = pd.DataFrame(
            {
                &#34;detector_id&#34;: detector,
                &#34;lon&#34;: df[df[&#34;detector_id&#34;] == detector][&#34;lon&#34;].iloc[0],
                &#34;lat&#34;: df[df[&#34;detector_id&#34;] == detector][&#34;lat&#34;].iloc[0],
                &#34;measurement_start_utc&#34;: T,
                &#34;measurement_end_utc&#34;: T + np.timedelta64(1, &#34;h&#34;),
                &#34;n_vehicles_in_interval&#34;: testPredict.flatten(),
                &#34;prediction_variance&#34;: testVar.flatten(),
            }
        )

        framelist.append(df2)

    return pd.concat(framelist)</code></pre>
</details>
</dd>
<dt id="SpatialScan.timeseriesjam.GP_forecast_gaps"><code class="name flex">
<span>def <span class="ident">GP_forecast_gaps</span></span>(<span>df: pandas.core.frame.DataFrame, days_in_past: int = 2, days_in_future: int = 1, detectors: list = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Forecast using Gaussian Processes
Args:
df: Dataframe of JamCam data
days_in_past: Integer number of previous days to use for forecast
days_in_future: Days in future produce a for forecast for
detectors: List of detectors to look at</p>
<h2 id="returns">Returns</h2>
<p>Dataframe forecast in same format as JamCam input dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GP_forecast_gaps(
    df: pd.DataFrame,
    days_in_past: int = 2,
    days_in_future: int = 1,
    detectors: list = None,
) -&gt; pd.DataFrame:

    &#34;&#34;&#34;Forecast using Gaussian Processes 
    Args: 
        df: Dataframe of JamCam data
        days_in_past: Integer number of previous days to use for forecast
        days_in_future: Days in future produce a for forecast for
        detectors: List of detectors to look at


    Returns:
        Dataframe forecast in same format as JamCam input dataframe

        &#34;&#34;&#34;

    # extract numpy array of detector ID&#39;s
    if detectors is None:
        detectors = df[&#34;detector_id&#34;].drop_duplicates().to_numpy()
    framelist = []

    i = 0
    for detector in detectors:
        i += 1

        dataset = df[df[&#34;detector_id&#34;] == detector].tail(n=16 * days_in_past)

        Y = dataset[&#34;n_vehicles_in_interval&#34;].to_numpy().reshape(-1, 1)
        Y = Y.astype(float)
        X = np.arange(1, len(Y) + 1, dtype=float).reshape(-1, 1)

        scaler = MinMaxScaler(feature_range=(-1, 1))
        y = scaler.fit_transform(Y)

        kern_pD = gpflow.kernels.Periodic(gpflow.kernels.SquaredExponential())
        kern_pW = gpflow.kernels.Periodic(gpflow.kernels.SquaredExponential())
        kern_SE = gpflow.kernels.SquaredExponential()
        kern_W = gpflow.kernels.White()
        # kern_M = gpflow.kernels.Matern52()

        kern_pD.period.assign(16.0)
        # kern_pD.base_kernel.variance.assign(10)
        kern_pW.period.assign(112.0)
        # kern_pW.base_kernel.variance.assign(10)

        k = kern_pD * kern_pW + kern_SE + kern_W

        m = gpflow.models.GPR(data=(X, y), kernel=k, mean_function=None)
        opt = gpflow.optimizers.Scipy()
        opt_logs = opt.minimize(
            m.training_loss, m.trainable_variables, options=dict(maxiter=100)
        )

        print(&#34;please wait: &#34;, i, &#34;/&#34;, len(detectors), end=&#34;\r&#34;)

        ## generate test points for prediction
        xx = np.linspace(
            len(Y) + 1, len(Y) + (days_in_future * 16) + 1, (days_in_future * 16)
        ).reshape(
            (days_in_future * 16), 1
        )  # test points must be of shape (N, D)

        ## predict mean and variance of latent GP at test points
        mean, var = m.predict_f(xx)

        # reverse min_max scaler
        testPredict = scaler.inverse_transform(mean)
        testVar = scaler.inverse_transform(var)

        # find the time period for our testPredictions
        start_date = dataset[&#34;measurement_end_utc&#34;].max() + np.timedelta64(8, &#34;h&#34;)
        end_date = (start_date + np.timedelta64(16 + (24 * (days_in_future - 1)), &#34;h&#34;),)

        # print(start_date, end_date)
        N_days = days_in_future
        T = pd.date_range(start=start_date, periods=16, freq=&#34;H&#34;)
        start_of_day = start_date + np.timedelta64(1, &#34;D&#34;)
        for d in range(0, N_days - 1):
            t = pd.date_range(
                start=start_of_day, end=start_of_day + np.timedelta64(15, &#34;h&#34;), freq=&#34;H&#34;
            ).to_numpy()

            T = np.append(T, t)
            start_of_day = start_of_day + np.timedelta64(1, &#34;D&#34;)

        T = np.array(T)

        # organise data into dataframe similar to the SCOOT outputs
        df2 = pd.DataFrame(
            {
                &#34;detector_id&#34;: detector,
                &#34;lon&#34;: df[df[&#34;detector_id&#34;] == detector][&#34;lon&#34;].iloc[0],
                &#34;lat&#34;: df[df[&#34;detector_id&#34;] == detector][&#34;lat&#34;].iloc[0],
                &#34;measurement_start_utc&#34;: T,
                &#34;measurement_end_utc&#34;: T + np.timedelta64(1, &#34;h&#34;),
                &#34;n_vehicles_in_interval&#34;: testPredict.flatten(),
                &#34;prediction_variance&#34;: testVar.flatten(),
            }
        )

        framelist.append(df2)

    return pd.concat(framelist)</code></pre>
</details>
</dd>
<dt id="SpatialScan.timeseriesjam.count_baselineJ"><code class="name flex">
<span>def <span class="ident">count_baselineJ</span></span>(<span>df: pandas.core.frame.DataFrame, days_in_past: int, days_in_future: int, method: str = 'HW', detectors: list = None, alpha: float = 0.1, beta: float = 0.1, gamma: float = 0.2, kern=None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Produces a DataFrame where the count and baseline can be compared for use
in scan statistics</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>Dataframe of JamCam data</dd>
<dt><strong><code>days_in_past</code></strong></dt>
<dd>Integer past days to train forecast one</dd>
<dt><strong><code>days_in_future</code></strong></dt>
<dd>Days in future produce a baseline too and record count for</dd>
<dt><strong><code>method</code></strong></dt>
<dd>Forecast method to use for baseline, default is "HW" for Holt-Winters, option for GP</dd>
<dt><strong><code>detectors</code></strong></dt>
<dd>List of detectors to look at</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dataframe of counts and baseline along with detector data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_baselineJ(
    df: pd.DataFrame,
    days_in_past: int,
    days_in_future: int,
    method: str = &#34;HW&#34;,
    detectors: list = None,
    alpha: float = 0.1,
    beta: float = 0.1,
    gamma: float = 0.2,
    kern = None
) -&gt; pd.DataFrame:

    &#34;&#34;&#34;Produces a DataFrame where the count and baseline can be compared for use
        in scan statistics

    Args:
        df: Dataframe of JamCam data
        days_in_past: Integer past days to train forecast one
        days_in_future: Days in future produce a baseline too and record count for
        method: Forecast method to use for baseline, default is &#34;HW&#34; for Holt-Winters, option for GP
        detectors: List of detectors to look at

    Returns:
        Dataframe of counts and baseline along with detector data

        &#34;&#34;&#34;

    t_min = df[&#34;measurement_start_utc&#34;].min()
    t_max = df[&#34;measurement_end_utc&#34;].max()

    print(&#34;Input dataframe contains data spanning {} to {}.&#34;.format(t_min, t_max))

    if detectors is None:
        detectors = df[&#34;detector_id&#34;].drop_duplicates().to_numpy()

    prediction_start = df[&#34;measurement_end_utc&#34;].iloc[-1] - np.timedelta64(
        days_in_future * 24, &#34;h&#34;
    )

    train_data = df[df[&#34;measurement_end_utc&#34;] &lt;= prediction_start]
    test_data = df[df[&#34;measurement_end_utc&#34;] &gt; prediction_start]

    avail_past_days = int(len(train_data[&#34;measurement_end_utc&#34;].unique()) / 16)
    if avail_past_days &lt; days_in_past:
        print(
            &#34;Input dataframe only contains {} days worth of data before the prediction period.&#34;.format(
                avail_past_days
            ),
            &#34;Setting days_in_past = {}.&#34;.format(avail_past_days),
        )

    print(
        &#34;Using data from {} to {}, to forecast counts between {} and {} for {} detectors using {} method...&#34;.format(
            t_min, prediction_start, prediction_start, t_max, len(detectors), method
        )
    )

    if method == &#34;HW&#34;:
        y = holt_wintersJ(
            train_data,
            days_in_past,
            days_in_future,
            alpha=alpha,
            beta=beta,
            gamma=gamma,
            detectors=detectors,
        )

    if method == &#34;GP&#34;:
        y = GP_forecast(
            train_data,
            days_in_past=days_in_past,
            days_in_future=days_in_future,
            detectors=detectors,
            kern = kern,
        )

    sd = []

    print(&#34;Forecasting complete.&#34;)

    for detector in detectors:

        sd.append(test_data[test_data[&#34;detector_id&#34;] == detector])

    sample_test_data = pd.concat(sd)

    Y = y.merge(
        sample_test_data,
        on=[
            &#34;lon&#34;,
            &#34;lat&#34;,
            &#34;measurement_end_utc&#34;,
            &#34;detector_id&#34;,
            &#34;measurement_start_utc&#34;,
        ],
        how=&#34;left&#34;,
    )
    Y = Y.rename(
        columns={
            &#34;n_vehicles_in_interval_x&#34;: &#34;baseline&#34;,
            &#34;n_vehicles_in_interval_y&#34;: &#34;count&#34;,
        }
    )

    # T = pd.date_range(
    #     start=Y[&#34;measurement_end_utc&#34;].min() - np.timedelta64(3, &#34;h&#34;),
    #     end=Y[&#34;measurement_end_utc&#34;].max() + np.timedelta64(5, &#34;h&#34;),
    #     freq=&#34;H&#34;,
    # )
    # dets = Y[&#34;detector_id&#34;].unique()
    # mux = pd.MultiIndex.from_product(
    #     [dets, T], names=(&#34;detector_id&#34;, &#34;measurement_end_utc&#34;)
    # )
    # Y = Y.set_index([&#34;detector_id&#34;, &#34;measurement_end_utc&#34;])
    # Y = Y.reindex(mux)

    # Y = Y.reset_index()

    return Y</code></pre>
</details>
</dd>
<dt id="SpatialScan.timeseriesjam.forecast_plotJ"><code class="name flex">
<span>def <span class="ident">forecast_plotJ</span></span>(<span>df: pandas.core.frame.DataFrame, detector: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that plots the Count against the forecasted Baseline</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>Dataframe with Time, Count and Baseline columns</dd>
<dt><strong><code>detector</code></strong></dt>
<dd>String of detector name, if none detector chosen at random</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forecast_plotJ(df: pd.DataFrame, detector: str = None):
    &#34;&#34;&#34;Function that plots the Count against the forecasted Baseline
        
        Args:
            df: Dataframe with Time, Count and Baseline columns
            detector: String of detector name, if none detector chosen at random&#34;&#34;&#34;

    detectors = df[&#34;detector_id&#34;].drop_duplicates()
    if detector is None:
        detector = detectors.sample(n=1).to_numpy()[0]

    df_d = df[df[&#34;detector_id&#34;] == detector]
    print(detector)
    df_d = df_d.sort_values(&#34;measurement_end_utc&#34;)
    ax=df_d.plot(x=&#34;measurement_end_utc&#34;, y=[&#34;baseline&#34;, &#34;count&#34;])
    if &#34;prediction_variance&#34; in df_d.columns:
        plt.fill_between(
            df_d[&#34;measurement_end_utc&#34;],
            df_d[&#34;baseline&#34;] + 2*np.sqrt(df_d[&#34;prediction_variance&#34;]),
            df_d[&#34;baseline&#34;] - 2*np.sqrt(df_d[&#34;prediction_variance&#34;]),
            color=&#34;C0&#34;,
            alpha=0.5, label= &#34;2$\sigma$&#34;)
    plt.legend()</code></pre>
</details>
</dd>
<dt id="SpatialScan.timeseriesjam.holt_wintersJ"><code class="name flex">
<span>def <span class="ident">holt_wintersJ</span></span>(<span>df: pandas.core.frame.DataFrame, days_in_past: int, days_in_future: int, alpha: float = 0.05, beta: float = 0.05, gamma: float = 0.4, display: bool = False, detectors: list = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Average forecast using Holt-Winters method for JamCam 16h cycles</p>
<p>Args:
df: Dataframe of JamCam data
detectors: List of detectors to look at
days_in_past: Integer number of previous days to use for forecast
days_in_future: Days in future produce a for forecast for
display: boolean which determines whether to plot forecast
alpha, beta, gamma: optimisation parameters</p>
<h2 id="returns">Returns</h2>
<p>Dataframe forecast in same format as JamCam input dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def holt_wintersJ(
    df: pd.DataFrame,
    days_in_past: int,
    days_in_future: int,
    alpha: float = 0.05,
    beta: float = 0.05,
    gamma: float = 0.4,
    display: bool = False,
    detectors: list = None,
) -&gt; pd.DataFrame:

    &#34;&#34;&#34;Average forecast using Holt-Winters method for JamCam 16h cycles

    Args: 
        df: Dataframe of JamCam data
        detectors: List of detectors to look at
        days_in_past: Integer number of previous days to use for forecast
        days_in_future: Days in future produce a for forecast for
        display: boolean which determines whether to plot forecast
        alpha, beta, gamma: optimisation parameters

    Returns:
        Dataframe forecast in same format as JamCam input dataframe

        &#34;&#34;&#34;

    if detectors is None:
        detectors = df[&#34;detector_id&#34;].drop_duplicates().to_numpy()

    framelist = []
    for detector in detectors:
        S = 1
        T = 1
        I = np.ones(16)
        one_D = df[df[&#34;detector_id&#34;] == detector]
        one_D = one_D.sort_values(by=[&#34;measurement_end_utc&#34;])
        past = one_D.tail(n=16 * days_in_past)
        for i in range(0, len(past)):
            h = i % 16
            c = past[&#34;n_vehicles_in_interval&#34;].iloc[i]
            Snew = (alpha * (c / I[h])) + (1 - alpha) * (S + T)
            T = beta * (Snew - S) + (1 - beta) * T
            I[h] = gamma * (c / Snew) + (1 - gamma) * I[h]
            S = Snew

        baseline = []
        endtime = []
        starttime = []
        shift = 1
        for j in range(0, days_in_future * 16):
            h = j % 16
            if h == 0:
                shift += 8
            end = df[&#34;measurement_end_utc&#34;].to_numpy()[-1] + np.timedelta64(
                j + shift, &#34;h&#34;
            )
            start = df[&#34;measurement_start_utc&#34;].to_numpy()[-1] + np.timedelta64(
                j + shift, &#34;h&#34;
            )

            b = (S + T) * I[h]
            baseline.append(b)
            endtime.append(end)
            starttime.append(start)

            Snew = (alpha * (b / I[h])) + (1 - alpha) * (S + T)
            T = beta * (Snew - S) + (1 - beta) * T
            I[h] = gamma * (b / Snew) + (1 - gamma) * I[h]
            S = Snew

        df2 = pd.DataFrame(
            {
                &#34;detector_id&#34;: detector,
                &#34;lon&#34;: one_D[one_D[&#34;detector_id&#34;] == detector][&#34;lon&#34;].iloc[0],
                &#34;lat&#34;: one_D[one_D[&#34;detector_id&#34;] == detector][&#34;lat&#34;].iloc[0],
                &#34;measurement_start_utc&#34;: starttime,
                &#34;measurement_end_utc&#34;: endtime,
                &#34;n_vehicles_in_interval&#34;: baseline,
            }
        )
        framelist.append(df2)
    DF = pd.concat(framelist)

    if display:
        df_plot = DF.set_index(&#34;measurement_end_utc&#34;)
        for detector in detectors:
            df_plot[df_plot[&#34;detector_id&#34;] == detector][&#34;n_vehicles_in_interval&#34;].plot()

    return DF</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="SpatialScan" href="index.html">SpatialScan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="SpatialScan.timeseriesjam.CB_plotJ" href="#SpatialScan.timeseriesjam.CB_plotJ">CB_plotJ</a></code></li>
<li><code><a title="SpatialScan.timeseriesjam.GP_forecast" href="#SpatialScan.timeseriesjam.GP_forecast">GP_forecast</a></code></li>
<li><code><a title="SpatialScan.timeseriesjam.GP_forecast_gaps" href="#SpatialScan.timeseriesjam.GP_forecast_gaps">GP_forecast_gaps</a></code></li>
<li><code><a title="SpatialScan.timeseriesjam.count_baselineJ" href="#SpatialScan.timeseriesjam.count_baselineJ">count_baselineJ</a></code></li>
<li><code><a title="SpatialScan.timeseriesjam.forecast_plotJ" href="#SpatialScan.timeseriesjam.forecast_plotJ">forecast_plotJ</a></code></li>
<li><code><a title="SpatialScan.timeseriesjam.holt_wintersJ" href="#SpatialScan.timeseriesjam.holt_wintersJ">holt_wintersJ</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>