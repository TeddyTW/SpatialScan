<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>SpatialScan.results API documentation</title>
<meta name="description" content="Module to contain all functionality required to display results from the
main Expectation-Based Scan Statistic Loop" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SpatialScan.results</code></h1>
</header>
<section id="section-intro">
<p>Module to contain all functionality required to display results from the
main Expectation-Based Scan Statistic Loop</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module to contain all functionality required to display results from the
main Expectation-Based Scan Statistic Loop&#34;&#34;&#34;

import plotly.graph_objects as go
import pandas as pd
import numpy as np
from shapely.geometry import Point
from shapely.ops import unary_union
import geopandas as gpd


def title_generator(scan_type: str, i: int, t_labels: np.ndarray) -&gt; str:
    &#34;&#34;&#34;Quick utility function to create labels based on the tye of search.
    Accounts for the varying/non-varying t_max in both regimes.
    Args:
        scan_type: &#34;normal&#34; or &#34;exhaustive&#34;
        i: loop iteration
        t_labels: Array of t_tick labels for plotting
    Returns:
        String representing the appropiate label for graph.
    &#34;&#34;&#34;
    if scan_type == &#34;normal&#34;:
        return &#34;{} to {}&#34;.format(t_labels[i], t_labels[len(t_labels) - 1])
    elif scan_type == &#34;exhaustive&#34;:
        return &#34;{} to {}&#34;.format(t_labels[i], t_labels[i + 1])
    return None


def visualise_results(
    res_df,
    metric: str = &#34;l_score_EBP&#34;,
    smooth: bool = False,
    c_min: float = None,
    c_max: float = None,
) -&gt; None:
    &#34;&#34;&#34;Functionality which plots the animated results of the Spatial Scan.

    Args:
        res_df: resulting dataframe from `EBP()`
        metric: Which metric to plot from res_df
        smooth: Boolean which decides whether to smooth the spatial region in
                the animation or not.
        c_min: Minimum value to set the color bar
        c_max: Maximum value to set the color bar.
    &#34;&#34;&#34;
    assert (set([metric])) &lt;= set(res_df.columns)

    # What type of scan was it? Normal or Exhaustive?
    # Only way to tell is by the number of unique t_maxs in res_df
    num_t_maxs = len(res_df[&#34;t_max&#34;].unique())

    # If more than one t_max, scan was exhaustive
    if num_t_maxs &gt; 1:
        scan_type = &#34;exhaustive&#34;
    else:
        scan_type = &#34;normal&#34;

    # Infer grid partition form the resulting dataframe
    grid_partition = len(res_df[&#34;x_min&#34;].unique())

    # Infer Spatial Grid extent from resulting dataframe
    x_min = res_df[&#34;x_min&#34;].min()
    x_max = res_df[&#34;x_max&#34;].max()
    y_min = res_df[&#34;y_min&#34;].min()
    y_max = res_df[&#34;y_max&#34;].max()
    t_min = res_df[&#34;t_min&#34;].min()
    t_max = res_df[&#34;t_max&#34;].max()

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)
    t_ticks = pd.date_range(start=t_min, end=t_max, freq=&#34;H&#34;)

    # Use these to explicitly return labels
    x_labels = [
        &#34;{0:.3f}&#34;.format((x_ticks[i] + x_ticks[i + 1]) / 2)
        for i in range(len(x_ticks) - 1)
    ]
    y_labels = [
        &#34;{0:.3f}&#34;.format((y_ticks[i] + y_ticks[i + 1]) / 2)
        for i in reversed(range(len(y_ticks) - 1))
    ]

    t_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_ticks]

    # Find array of ordered dates over prediction period and format pretty for
    # plot.
    res_df = res_df.sort_values(by=[&#34;t_max&#34;])

    scores_array = []
    global_max = -np.inf
    global_min = np.inf
    for t in range(len(t_ticks) - 1):
        x_array = []
        for j in range(len(y_ticks) - 1):
            y_array = []
            for i in range(len(x_ticks) - 1):

                sub_df = res_df[
                    (res_df[&#34;x_min&#34;] &lt;= x_ticks[i])
                    &amp; (res_df[&#34;x_max&#34;] &gt;= x_ticks[i + 1])
                    &amp; (res_df[&#34;y_min&#34;] &lt;= y_ticks[j])
                    &amp; (res_df[&#34;y_max&#34;] &gt;= y_ticks[j + 1])
                    &amp; (res_df[&#34;t_min&#34;] == t_ticks[t])
                    &amp; (
                        res_df[&#34;t_max&#34;]
                        == t_ticks[len(t_ticks) - 1 if scan_type == &#34;normal&#34; else t + 1]
                    )
                ]

                l_score = sub_df[metric].mean()

                if l_score &gt; global_max:
                    global_max = l_score
                if l_score &lt; global_min:
                    global_min = l_score

                y_array.append(l_score)
            x_array.insert(0, y_array)
        scores_array.append(x_array)

    zsmooth = &#34;best&#34; if smooth else None
    c_min = global_min if c_min is None else c_min
    c_max = global_max if c_max is None else c_max

    fig = go.Figure(
        data=[
            go.Heatmap(
                z=scores_array[0],
                x=x_labels,
                y=y_labels,
                zmin=c_min,
                zmax=c_max,
                zsmooth=zsmooth,
                colorbar={&#34;title&#34;: &#34;Average Likelihood Ratio Score&#34;},
            )
        ],
        layout=go.Layout(
            title=&#34;{} to {}&#34;.format(t_labels[0], t_labels[len(t_labels) - 1]),
            width=800,
            height=500,
            updatemenus=[
                dict(
                    type=&#34;buttons&#34;,
                    buttons=[
                        dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                        dict(
                            label=&#34;Pause&#34;,
                            method=&#34;animate&#34;,
                            args=[
                                None,
                                {
                                    &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                    &#34;mode&#34;: &#34;immediate&#34;,
                                    &#34;transition&#34;: {&#34;duration&#34;: 0},
                                },
                            ],
                        ),
                    ],
                )
            ],
        ),
        frames=[
            go.Frame(
                data=[go.Heatmap(z=scores_array[i], zmin=c_min, zmax=c_max)],
                layout=go.Layout(title=title_generator(scan_type, i, t_labels)),
            )
            for i in range(0, len(t_labels) - 1)
        ],
    )
    fig.update_layout(
        xaxis_title=&#34;Longitude&#34;, yaxis_title=&#34;Latitude&#34;,
    )
    fig.show()
    return {&#34;max&#34;: c_max, &#34;min&#34;: c_min}


def database_results(res_df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Functionality to produce a dataframe in the correct format for storage
    in the database. It may not be what we want perfectly atm, but template
    functionality is in place. Calculates the average likelihood per grid cell.
    Beware: this means different things depending on which function (`EBP()` or
    `EBP_exhaustive()`) was called.

    Args:
        res_df: Resulting dataframe from `EBP()` OR `EBP_exhaustive()`
    Returns:
        pd.DataFrame in format for storage.
    &#34;&#34;&#34;

    # What type of scan was it? Normal or Exhaustive?
    # Only way to tell is by the number of unuique t_maxs in res_df
    num_t_maxs = len(res_df[&#34;t_max&#34;].unique())

    # If more than one t_max, scan was exhaustive
    if num_t_maxs &gt; 1:
        scan_type = &#34;exhaustive&#34;
    else:
        scan_type = &#34;normal&#34;

    # Infer grid partition form the resulting dataframe
    grid_partition = len(res_df[&#34;x_min&#34;].unique())

    # Infer Spatial Grid extent from resulting dataframe
    x_min = res_df[&#34;x_min&#34;].min()
    x_max = res_df[&#34;x_max&#34;].max()
    y_min = res_df[&#34;y_min&#34;].min()
    y_max = res_df[&#34;y_max&#34;].max()
    t_min = res_df[&#34;t_min&#34;].min()
    t_max = res_df[&#34;t_max&#34;].max()

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)
    t_ticks = pd.date_range(start=t_min, end=t_max, freq=&#34;H&#34;)

    return_dict = {}
    num_regions = 0
    for t in range(len(t_ticks) - 1):
        num_spatial_regions = 0
        for j in range(len(y_ticks) - 1):
            for i in range(len(x_ticks) - 1):

                sub_df = res_df[
                    (res_df[&#34;x_min&#34;] &lt;= x_ticks[i])
                    &amp; (res_df[&#34;x_max&#34;] &gt;= x_ticks[i + 1])
                    &amp; (res_df[&#34;y_min&#34;] &lt;= y_ticks[j])
                    &amp; (res_df[&#34;y_max&#34;] &gt;= y_ticks[j + 1])
                    &amp; (res_df[&#34;t_min&#34;] == t_ticks[t])
                    &amp; (
                        res_df[&#34;t_max&#34;]
                        == t_ticks[len(t_ticks) - 1 if scan_type == &#34;normal&#34; else t + 1]
                    )
                ]

                B, C = sub_df[[&#34;B_in&#34;, &#34;C_in&#34;]].sum()

                means = sub_df[
                    [
                        &#34;l_score_EBP_lower&#34;,
                        &#34;l_score_EBP&#34;,
                        &#34;l_score_EBP_upper&#34;,
                        &#34;l_score_000_lower&#34;,
                        &#34;l_score_000&#34;,
                        &#34;l_score_000_upper&#34;,
                        &#34;l_score_025_lower&#34;,
                        &#34;l_score_025&#34;,
                        &#34;l_score_025_upper&#34;,
                        &#34;l_score_050_lower&#34;,
                        &#34;l_score_050&#34;,
                        &#34;l_score_050_upper&#34;,
                        &#34;posterior_bbayes&#34;,
                    ]
                ].mean()

                return_dict[num_regions] = {
                    &#34;start_time_utc&#34;: t_ticks[t],
                    &#34;end_time_utc&#34;: t_ticks[
                        len(t_ticks) - 1 if scan_type == &#34;normal&#34; else t + 1
                    ],
                    &#34;point_id&#34;: num_spatial_regions,
                    &#34;x_min&#34;: x_ticks[i],
                    &#34;x_max&#34;: x_ticks[i + 1],
                    &#34;y_min&#34;: y_ticks[j],
                    &#34;y_max&#34;: y_ticks[j + 1],
                    &#34;observed_count&#34;: C,
                    &#34;forecasted_count&#34;: B,
                    &#34;av_lhd_score_EBP_lower&#34;: means[&#34;l_score_EBP_lower&#34;],
                    &#34;av_lhd_score_EBP&#34;: means[&#34;l_score_EBP&#34;],
                    &#34;av_lhd_score_EBP_upper&#34;: means[&#34;l_score_EBP_upper&#34;],
                    &#34;av_lhd_score_eps_000_lower&#34;: means[&#34;l_score_000_lower&#34;],
                    &#34;av_lhd_score_eps_000&#34;: means[&#34;l_score_000&#34;],
                    &#34;av_lhd_score_eps_000_upper&#34;: means[&#34;l_score_000_upper&#34;],
                    &#34;av_lhd_score_eps_025_lower&#34;: means[&#34;l_score_025_lower&#34;],
                    &#34;av_lhd_score_eps_025&#34;: means[&#34;l_score_025&#34;],
                    &#34;av_lhd_score_eps_025_upper&#34;: means[&#34;l_score_025_upper&#34;],
                    &#34;av_lhd_score_eps_050_lower&#34;: means[&#34;l_score_050_lower&#34;],
                    &#34;av_lhd_score_eps_050&#34;: means[&#34;l_score_050&#34;],
                    &#34;av_lhd_score_eps_050_upper&#34;: means[&#34;l_score_050_upper&#34;],
                    &#34;av_posterior_bbayes&#34;: means[&#34;posterior_bbayes&#34;],
                }

                num_spatial_regions += 1
                num_regions += 1
    return pd.DataFrame.from_dict(return_dict, &#34;index&#34;)


def visualise_results_from_database(
    database_df,
    metric: str = &#34;av_lhd_score_EBP&#34;,
    smooth: bool = False,
    c_min: float = None,
    c_max: float = None,
):

    &#34;&#34;&#34;Allows reconstruction of the plot from any time slice of database data.
    the above make the plots directly from the output of `scan()`

    Args:
        database_df: dataframe from database storage
        metric: Which metric to plot from database_df
        smooth: Boolean which decides whether to smooth the spatial region in
                the animation or not.
        c_min: Minimum value to set the color bar
        c_max: Maximum value to set the color bar.
    &#34;&#34;&#34;

    assert (set([metric])) &lt;= set(database_df.columns)

    times = database_df[&#34;start_time_utc&#34;].unique()
    grid_partition = len(database_df[&#34;x_min&#34;].unique())

    x_min = database_df[&#34;x_min&#34;].min()
    x_max = database_df[&#34;x_max&#34;].max()
    y_min = database_df[&#34;y_min&#34;].min()
    y_max = database_df[&#34;y_max&#34;].max()
    t_min = database_df[&#34;start_time_utc&#34;].min()
    t_max = database_df[&#34;end_time_utc&#34;].max()

    print(
        &#34;Dataframe contains data from the database spanning {} to {}.&#34;.format(
            t_min, t_max
        )
    )

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)

    # Use these to explicitly return labels
    x_labels = [
        &#34;{0:.3f}&#34;.format((x_ticks[i] + x_ticks[i + 1]) / 2)
        for i in range(len(x_ticks) - 1)
    ]
    y_labels = [
        &#34;{0:.3f}&#34;.format((y_ticks[i] + y_ticks[i + 1]) / 2)
        for i in reversed(range(len(y_ticks) - 1))
    ]

    # Pick random time series to get correct dates
    # XXX - point Id will need to be changed eventually.
    example_df = database_df[database_df[&#34;point_id&#34;] == 0]

    t_min_ticks = example_df[&#34;start_time_utc&#34;]
    t_max_ticks = example_df[&#34;end_time_utc&#34;]
    t_min_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_min_ticks]
    t_max_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_max_ticks]

    scores_array = []
    for time in times:
        scores = database_df[database_df[&#34;start_time_utc&#34;] == time][metric].to_numpy()
        scores = np.reshape(scores, (grid_partition, grid_partition))

        # Reverse the array for plotting convention (low y is high)
        scores = scores[::-1]

        scores_array.append(scores)

    global_min = np.min(scores_array)
    global_max = np.max(scores_array)

    # Below is all plotting
    zsmooth = &#34;best&#34; if smooth else None
    c_min = global_min if c_min is None else c_min
    c_max = global_max if c_max is None else c_max

    fig = go.Figure(
        data=[
            go.Heatmap(
                z=scores_array[0],
                x=x_labels,
                y=y_labels,
                zmin=c_min,
                zmax=c_max,
                zsmooth=zsmooth,
                colorbar={&#34;title&#34;: &#34;Average Likelihood Ratio Score&#34;},
            )
        ],
        layout=go.Layout(
            title=&#34;{} to {}&#34;.format(t_min_labels[0], t_max_labels[0]),
            width=800,
            height=500,
            updatemenus=[
                dict(
                    type=&#34;buttons&#34;,
                    buttons=[
                        dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                        dict(
                            label=&#34;Pause&#34;,
                            method=&#34;animate&#34;,
                            args=[
                                None,
                                {
                                    &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                    &#34;mode&#34;: &#34;immediate&#34;,
                                    &#34;transition&#34;: {&#34;duration&#34;: 0},
                                },
                            ],
                        ),
                    ],
                )
            ],
        ),
        frames=[
            go.Frame(
                data=[go.Heatmap(z=scores_array[i], zmin=c_min, zmax=c_max)],
                layout=go.Layout(
                    title=&#34;{} to {}&#34;.format(t_min_labels[i], t_max_labels[i])
                ),
            )
            for i in range(0, len(t_min_labels))
        ],
    )
    fig.update_layout(
        xaxis_title=&#34;Longitude&#34;, yaxis_title=&#34;Latitude&#34;,
    )
    fig.show()
    return {&#34;max&#34;: c_max, &#34;min&#34;: c_min}


class MapboxPlot:
    def __init__(self, database_df, london_gpd, borough=&#39;all&#39;):
        self.database_df = database_df
        self.london_gpd = london_gpd
        self.borough = borough
        # Mapbox Token
        self.token = &#34;pk.eyJ1IjoiY2hhbmNlaGF5Y29jayIsImEiOiJja2Q0d25iNjMxYTgxMnNudzUzdm9veG5xIn0.MNo8CDYOo6z_g1lWiRM3vg&#34;
        self.masked_results = None

    def _preprocess_database_results(self):
        # Add centroid
        self.database_df[&#34;lon&#34;] = (
            self.database_df[&#34;x_min&#34;] + self.database_df[&#34;x_max&#34;]
        ) / 2
        self.database_df[&#34;lat&#34;] = (
            self.database_df[&#34;y_min&#34;] + self.database_df[&#34;y_max&#34;]
        ) / 2

        # Shapely formatting
        self.database_df[&#34;location&#34;] = self.database_df.apply(
            lambda x: Point(x.lon, x.lat), axis=1
        )

        # Project the london boroughs to standard
        self.london_gpd = self.london_gpd.to_crs(epsg=4326)

        if self.borough in [&#39;All&#39;, &#39;all&#39;, &#39;London&#39;, &#39;london&#39;]:
            boundary = gpd.GeoSeries(unary_union(self.london_gpd.geometry))
        else:
            boundary = self.london_gpd[self.london_gpd[&#39;NAME&#39;] == self.borough]

        # Does all time steps at the mo - inefficient
        self.database_df[&#34;in_borough&#34;] = self.database_df.apply(
            lambda x: boundary.contains(x.location), axis=1
        )

        self.masked_results = self.database_df[self.database_df[&#34;in_borough&#34;]]

    def display(self, metric, zmin=None, zmax=None):
        if not isinstance(self.masked_results, pd.DataFrame):
            self._preprocess_database_results()

        unique_times = self.masked_results.drop_duplicates(
            subset=[&#34;start_time_utc&#34;, &#34;end_time_utc&#34;]
        )

        t_min_ticks = unique_times[&#34;start_time_utc&#34;]
        t_max_ticks = unique_times[&#34;end_time_utc&#34;]
        t_min_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_min_ticks]
        t_max_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_max_ticks]

        global_min = self.masked_results[metric].min()
        global_max = self.masked_results[metric].max()

        zmin = global_min if zmin is None else zmin
        zmax = global_max if zmax is None else zmax

        start_time = unique_times[&#34;start_time_utc&#34;].min()

        fig = go.Figure(
            data=go.Densitymapbox(
                lon=self.masked_results[
                    self.masked_results[&#34;start_time_utc&#34;] == start_time
                ][&#34;lon&#34;],
                lat=self.masked_results[
                    self.masked_results[&#34;start_time_utc&#34;] == start_time
                ][&#34;lat&#34;],
                z=self.masked_results[
                    self.masked_results[&#34;start_time_utc&#34;] == start_time
                ][metric],
                colorscale=&#34;viridis&#34;,
                radius=100,
                opacity=0.5,
                showscale=True,
                zmin=global_min,
                zmax=global_max,
                colorbar={
                    &#34;tickcolor&#34;: &#34;white&#34;,
                    &#34;tickfont&#34;: {&#34;color&#34;: &#34;white&#34;},
                    &#34;title&#34;: {&#34;text&#34;: &#34;Score&#34;, &#34;font&#34;: {&#34;color&#34;: &#34;white&#34;}},
                },
            ),
            layout=go.Layout(
                title=&#34;{} to {}&#34;.format(t_min_labels[0], t_max_labels[0]),
                updatemenus=[
                    dict(
                        type=&#34;buttons&#34;,
                        buttons=[
                            dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                            dict(
                                label=&#34;Pause&#34;,
                                method=&#34;animate&#34;,
                                args=[
                                    None,
                                    {
                                        &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                        &#34;mode&#34;: &#34;immediate&#34;,
                                        &#34;transition&#34;: {&#34;duration&#34;: 0},
                                    },
                                ],
                            ),
                        ],
                    ),
                ],
            ),
            frames=[
                go.Frame(
                    data=[
                        go.Densitymapbox(
                            lon=self.masked_results[
                                self.masked_results[&#34;start_time_utc&#34;]
                                == start_time + np.timedelta64(i, &#34;h&#34;)
                            ][&#34;lon&#34;],
                            lat=self.masked_results[
                                self.masked_results[&#34;start_time_utc&#34;]
                                == start_time + np.timedelta64(i, &#34;h&#34;)
                            ][&#34;lat&#34;],
                            z=self.masked_results[
                                self.masked_results[&#34;start_time_utc&#34;]
                                == start_time + np.timedelta64(i, &#34;h&#34;)
                            ][metric],
                        )
                    ],
                    layout=go.Layout(
                        title=&#34;{} to {}&#34;.format(t_min_labels[i], t_max_labels[i])
                    ),
                )
                for i in range(0, len(t_min_labels))
            ],
        )
        fig.update_layout(
            mapbox_style=&#34;dark&#34;,
            mapbox_accesstoken=self.token,
            margin={&#34;l&#34;: 0, &#34;r&#34;: 0, &#34;b&#34;: 0, &#34;t&#34;: 60},
            mapbox={&#34;center&#34;: {&#34;lon&#34;: -0.09, &#34;lat&#34;: 51.495}, &#34;zoom&#34;: 9.7},
            autosize=False,
            width=1600,
            height=900,
            paper_bgcolor=&#34;rgba(0,0,0,0)&#34;,
            plot_bgcolor=&#34;rgba(0,0,0,0)&#34;,
            # paper_bgcolor=&#39;black&#39;,
            title_font_color=&#34;white&#34;,
        )
        fig.show()
        return {&#34;max&#34;: zmax, &#34;min&#34;: zmin}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="SpatialScan.results.database_results"><code class="name flex">
<span>def <span class="ident">database_results</span></span>(<span>res_df: pandas.core.frame.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Functionality to produce a dataframe in the correct format for storage
in the database. It may not be what we want perfectly atm, but template
functionality is in place. Calculates the average likelihood per grid cell.
Beware: this means different things depending on which function (<code>EBP()</code> or
<code>EBP_exhaustive()</code>) was called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>res_df</code></strong></dt>
<dd>Resulting dataframe from <code>EBP()</code> OR <code>EBP_exhaustive()</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pd.DataFrame in format for storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def database_results(res_df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Functionality to produce a dataframe in the correct format for storage
    in the database. It may not be what we want perfectly atm, but template
    functionality is in place. Calculates the average likelihood per grid cell.
    Beware: this means different things depending on which function (`EBP()` or
    `EBP_exhaustive()`) was called.

    Args:
        res_df: Resulting dataframe from `EBP()` OR `EBP_exhaustive()`
    Returns:
        pd.DataFrame in format for storage.
    &#34;&#34;&#34;

    # What type of scan was it? Normal or Exhaustive?
    # Only way to tell is by the number of unuique t_maxs in res_df
    num_t_maxs = len(res_df[&#34;t_max&#34;].unique())

    # If more than one t_max, scan was exhaustive
    if num_t_maxs &gt; 1:
        scan_type = &#34;exhaustive&#34;
    else:
        scan_type = &#34;normal&#34;

    # Infer grid partition form the resulting dataframe
    grid_partition = len(res_df[&#34;x_min&#34;].unique())

    # Infer Spatial Grid extent from resulting dataframe
    x_min = res_df[&#34;x_min&#34;].min()
    x_max = res_df[&#34;x_max&#34;].max()
    y_min = res_df[&#34;y_min&#34;].min()
    y_max = res_df[&#34;y_max&#34;].max()
    t_min = res_df[&#34;t_min&#34;].min()
    t_max = res_df[&#34;t_max&#34;].max()

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)
    t_ticks = pd.date_range(start=t_min, end=t_max, freq=&#34;H&#34;)

    return_dict = {}
    num_regions = 0
    for t in range(len(t_ticks) - 1):
        num_spatial_regions = 0
        for j in range(len(y_ticks) - 1):
            for i in range(len(x_ticks) - 1):

                sub_df = res_df[
                    (res_df[&#34;x_min&#34;] &lt;= x_ticks[i])
                    &amp; (res_df[&#34;x_max&#34;] &gt;= x_ticks[i + 1])
                    &amp; (res_df[&#34;y_min&#34;] &lt;= y_ticks[j])
                    &amp; (res_df[&#34;y_max&#34;] &gt;= y_ticks[j + 1])
                    &amp; (res_df[&#34;t_min&#34;] == t_ticks[t])
                    &amp; (
                        res_df[&#34;t_max&#34;]
                        == t_ticks[len(t_ticks) - 1 if scan_type == &#34;normal&#34; else t + 1]
                    )
                ]

                B, C = sub_df[[&#34;B_in&#34;, &#34;C_in&#34;]].sum()

                means = sub_df[
                    [
                        &#34;l_score_EBP_lower&#34;,
                        &#34;l_score_EBP&#34;,
                        &#34;l_score_EBP_upper&#34;,
                        &#34;l_score_000_lower&#34;,
                        &#34;l_score_000&#34;,
                        &#34;l_score_000_upper&#34;,
                        &#34;l_score_025_lower&#34;,
                        &#34;l_score_025&#34;,
                        &#34;l_score_025_upper&#34;,
                        &#34;l_score_050_lower&#34;,
                        &#34;l_score_050&#34;,
                        &#34;l_score_050_upper&#34;,
                        &#34;posterior_bbayes&#34;,
                    ]
                ].mean()

                return_dict[num_regions] = {
                    &#34;start_time_utc&#34;: t_ticks[t],
                    &#34;end_time_utc&#34;: t_ticks[
                        len(t_ticks) - 1 if scan_type == &#34;normal&#34; else t + 1
                    ],
                    &#34;point_id&#34;: num_spatial_regions,
                    &#34;x_min&#34;: x_ticks[i],
                    &#34;x_max&#34;: x_ticks[i + 1],
                    &#34;y_min&#34;: y_ticks[j],
                    &#34;y_max&#34;: y_ticks[j + 1],
                    &#34;observed_count&#34;: C,
                    &#34;forecasted_count&#34;: B,
                    &#34;av_lhd_score_EBP_lower&#34;: means[&#34;l_score_EBP_lower&#34;],
                    &#34;av_lhd_score_EBP&#34;: means[&#34;l_score_EBP&#34;],
                    &#34;av_lhd_score_EBP_upper&#34;: means[&#34;l_score_EBP_upper&#34;],
                    &#34;av_lhd_score_eps_000_lower&#34;: means[&#34;l_score_000_lower&#34;],
                    &#34;av_lhd_score_eps_000&#34;: means[&#34;l_score_000&#34;],
                    &#34;av_lhd_score_eps_000_upper&#34;: means[&#34;l_score_000_upper&#34;],
                    &#34;av_lhd_score_eps_025_lower&#34;: means[&#34;l_score_025_lower&#34;],
                    &#34;av_lhd_score_eps_025&#34;: means[&#34;l_score_025&#34;],
                    &#34;av_lhd_score_eps_025_upper&#34;: means[&#34;l_score_025_upper&#34;],
                    &#34;av_lhd_score_eps_050_lower&#34;: means[&#34;l_score_050_lower&#34;],
                    &#34;av_lhd_score_eps_050&#34;: means[&#34;l_score_050&#34;],
                    &#34;av_lhd_score_eps_050_upper&#34;: means[&#34;l_score_050_upper&#34;],
                    &#34;av_posterior_bbayes&#34;: means[&#34;posterior_bbayes&#34;],
                }

                num_spatial_regions += 1
                num_regions += 1
    return pd.DataFrame.from_dict(return_dict, &#34;index&#34;)</code></pre>
</details>
</dd>
<dt id="SpatialScan.results.title_generator"><code class="name flex">
<span>def <span class="ident">title_generator</span></span>(<span>scan_type: str, i: int, t_labels: numpy.ndarray) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Quick utility function to create labels based on the tye of search.
Accounts for the varying/non-varying t_max in both regimes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scan_type</code></strong></dt>
<dd>"normal" or "exhaustive"</dd>
<dt><strong><code>i</code></strong></dt>
<dd>loop iteration</dd>
<dt><strong><code>t_labels</code></strong></dt>
<dd>Array of t_tick labels for plotting</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String representing the appropiate label for graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title_generator(scan_type: str, i: int, t_labels: np.ndarray) -&gt; str:
    &#34;&#34;&#34;Quick utility function to create labels based on the tye of search.
    Accounts for the varying/non-varying t_max in both regimes.
    Args:
        scan_type: &#34;normal&#34; or &#34;exhaustive&#34;
        i: loop iteration
        t_labels: Array of t_tick labels for plotting
    Returns:
        String representing the appropiate label for graph.
    &#34;&#34;&#34;
    if scan_type == &#34;normal&#34;:
        return &#34;{} to {}&#34;.format(t_labels[i], t_labels[len(t_labels) - 1])
    elif scan_type == &#34;exhaustive&#34;:
        return &#34;{} to {}&#34;.format(t_labels[i], t_labels[i + 1])
    return None</code></pre>
</details>
</dd>
<dt id="SpatialScan.results.visualise_results"><code class="name flex">
<span>def <span class="ident">visualise_results</span></span>(<span>res_df, metric: str = 'l_score_EBP', smooth: bool = False, c_min: float = None, c_max: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Functionality which plots the animated results of the Spatial Scan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>res_df</code></strong></dt>
<dd>resulting dataframe from <code>EBP()</code></dd>
<dt><strong><code>metric</code></strong></dt>
<dd>Which metric to plot from res_df</dd>
<dt><strong><code>smooth</code></strong></dt>
<dd>Boolean which decides whether to smooth the spatial region in
the animation or not.</dd>
<dt><strong><code>c_min</code></strong></dt>
<dd>Minimum value to set the color bar</dd>
<dt><strong><code>c_max</code></strong></dt>
<dd>Maximum value to set the color bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualise_results(
    res_df,
    metric: str = &#34;l_score_EBP&#34;,
    smooth: bool = False,
    c_min: float = None,
    c_max: float = None,
) -&gt; None:
    &#34;&#34;&#34;Functionality which plots the animated results of the Spatial Scan.

    Args:
        res_df: resulting dataframe from `EBP()`
        metric: Which metric to plot from res_df
        smooth: Boolean which decides whether to smooth the spatial region in
                the animation or not.
        c_min: Minimum value to set the color bar
        c_max: Maximum value to set the color bar.
    &#34;&#34;&#34;
    assert (set([metric])) &lt;= set(res_df.columns)

    # What type of scan was it? Normal or Exhaustive?
    # Only way to tell is by the number of unique t_maxs in res_df
    num_t_maxs = len(res_df[&#34;t_max&#34;].unique())

    # If more than one t_max, scan was exhaustive
    if num_t_maxs &gt; 1:
        scan_type = &#34;exhaustive&#34;
    else:
        scan_type = &#34;normal&#34;

    # Infer grid partition form the resulting dataframe
    grid_partition = len(res_df[&#34;x_min&#34;].unique())

    # Infer Spatial Grid extent from resulting dataframe
    x_min = res_df[&#34;x_min&#34;].min()
    x_max = res_df[&#34;x_max&#34;].max()
    y_min = res_df[&#34;y_min&#34;].min()
    y_max = res_df[&#34;y_max&#34;].max()
    t_min = res_df[&#34;t_min&#34;].min()
    t_max = res_df[&#34;t_max&#34;].max()

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)
    t_ticks = pd.date_range(start=t_min, end=t_max, freq=&#34;H&#34;)

    # Use these to explicitly return labels
    x_labels = [
        &#34;{0:.3f}&#34;.format((x_ticks[i] + x_ticks[i + 1]) / 2)
        for i in range(len(x_ticks) - 1)
    ]
    y_labels = [
        &#34;{0:.3f}&#34;.format((y_ticks[i] + y_ticks[i + 1]) / 2)
        for i in reversed(range(len(y_ticks) - 1))
    ]

    t_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_ticks]

    # Find array of ordered dates over prediction period and format pretty for
    # plot.
    res_df = res_df.sort_values(by=[&#34;t_max&#34;])

    scores_array = []
    global_max = -np.inf
    global_min = np.inf
    for t in range(len(t_ticks) - 1):
        x_array = []
        for j in range(len(y_ticks) - 1):
            y_array = []
            for i in range(len(x_ticks) - 1):

                sub_df = res_df[
                    (res_df[&#34;x_min&#34;] &lt;= x_ticks[i])
                    &amp; (res_df[&#34;x_max&#34;] &gt;= x_ticks[i + 1])
                    &amp; (res_df[&#34;y_min&#34;] &lt;= y_ticks[j])
                    &amp; (res_df[&#34;y_max&#34;] &gt;= y_ticks[j + 1])
                    &amp; (res_df[&#34;t_min&#34;] == t_ticks[t])
                    &amp; (
                        res_df[&#34;t_max&#34;]
                        == t_ticks[len(t_ticks) - 1 if scan_type == &#34;normal&#34; else t + 1]
                    )
                ]

                l_score = sub_df[metric].mean()

                if l_score &gt; global_max:
                    global_max = l_score
                if l_score &lt; global_min:
                    global_min = l_score

                y_array.append(l_score)
            x_array.insert(0, y_array)
        scores_array.append(x_array)

    zsmooth = &#34;best&#34; if smooth else None
    c_min = global_min if c_min is None else c_min
    c_max = global_max if c_max is None else c_max

    fig = go.Figure(
        data=[
            go.Heatmap(
                z=scores_array[0],
                x=x_labels,
                y=y_labels,
                zmin=c_min,
                zmax=c_max,
                zsmooth=zsmooth,
                colorbar={&#34;title&#34;: &#34;Average Likelihood Ratio Score&#34;},
            )
        ],
        layout=go.Layout(
            title=&#34;{} to {}&#34;.format(t_labels[0], t_labels[len(t_labels) - 1]),
            width=800,
            height=500,
            updatemenus=[
                dict(
                    type=&#34;buttons&#34;,
                    buttons=[
                        dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                        dict(
                            label=&#34;Pause&#34;,
                            method=&#34;animate&#34;,
                            args=[
                                None,
                                {
                                    &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                    &#34;mode&#34;: &#34;immediate&#34;,
                                    &#34;transition&#34;: {&#34;duration&#34;: 0},
                                },
                            ],
                        ),
                    ],
                )
            ],
        ),
        frames=[
            go.Frame(
                data=[go.Heatmap(z=scores_array[i], zmin=c_min, zmax=c_max)],
                layout=go.Layout(title=title_generator(scan_type, i, t_labels)),
            )
            for i in range(0, len(t_labels) - 1)
        ],
    )
    fig.update_layout(
        xaxis_title=&#34;Longitude&#34;, yaxis_title=&#34;Latitude&#34;,
    )
    fig.show()
    return {&#34;max&#34;: c_max, &#34;min&#34;: c_min}</code></pre>
</details>
</dd>
<dt id="SpatialScan.results.visualise_results_from_database"><code class="name flex">
<span>def <span class="ident">visualise_results_from_database</span></span>(<span>database_df, metric: str = 'av_lhd_score_EBP', smooth: bool = False, c_min: float = None, c_max: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows reconstruction of the plot from any time slice of database data.
the above make the plots directly from the output of <code>scan()</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>database_df</code></strong></dt>
<dd>dataframe from database storage</dd>
<dt><strong><code>metric</code></strong></dt>
<dd>Which metric to plot from database_df</dd>
<dt><strong><code>smooth</code></strong></dt>
<dd>Boolean which decides whether to smooth the spatial region in
the animation or not.</dd>
<dt><strong><code>c_min</code></strong></dt>
<dd>Minimum value to set the color bar</dd>
<dt><strong><code>c_max</code></strong></dt>
<dd>Maximum value to set the color bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualise_results_from_database(
    database_df,
    metric: str = &#34;av_lhd_score_EBP&#34;,
    smooth: bool = False,
    c_min: float = None,
    c_max: float = None,
):

    &#34;&#34;&#34;Allows reconstruction of the plot from any time slice of database data.
    the above make the plots directly from the output of `scan()`

    Args:
        database_df: dataframe from database storage
        metric: Which metric to plot from database_df
        smooth: Boolean which decides whether to smooth the spatial region in
                the animation or not.
        c_min: Minimum value to set the color bar
        c_max: Maximum value to set the color bar.
    &#34;&#34;&#34;

    assert (set([metric])) &lt;= set(database_df.columns)

    times = database_df[&#34;start_time_utc&#34;].unique()
    grid_partition = len(database_df[&#34;x_min&#34;].unique())

    x_min = database_df[&#34;x_min&#34;].min()
    x_max = database_df[&#34;x_max&#34;].max()
    y_min = database_df[&#34;y_min&#34;].min()
    y_max = database_df[&#34;y_max&#34;].max()
    t_min = database_df[&#34;start_time_utc&#34;].min()
    t_max = database_df[&#34;end_time_utc&#34;].max()

    print(
        &#34;Dataframe contains data from the database spanning {} to {}.&#34;.format(
            t_min, t_max
        )
    )

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)

    # Use these to explicitly return labels
    x_labels = [
        &#34;{0:.3f}&#34;.format((x_ticks[i] + x_ticks[i + 1]) / 2)
        for i in range(len(x_ticks) - 1)
    ]
    y_labels = [
        &#34;{0:.3f}&#34;.format((y_ticks[i] + y_ticks[i + 1]) / 2)
        for i in reversed(range(len(y_ticks) - 1))
    ]

    # Pick random time series to get correct dates
    # XXX - point Id will need to be changed eventually.
    example_df = database_df[database_df[&#34;point_id&#34;] == 0]

    t_min_ticks = example_df[&#34;start_time_utc&#34;]
    t_max_ticks = example_df[&#34;end_time_utc&#34;]
    t_min_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_min_ticks]
    t_max_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_max_ticks]

    scores_array = []
    for time in times:
        scores = database_df[database_df[&#34;start_time_utc&#34;] == time][metric].to_numpy()
        scores = np.reshape(scores, (grid_partition, grid_partition))

        # Reverse the array for plotting convention (low y is high)
        scores = scores[::-1]

        scores_array.append(scores)

    global_min = np.min(scores_array)
    global_max = np.max(scores_array)

    # Below is all plotting
    zsmooth = &#34;best&#34; if smooth else None
    c_min = global_min if c_min is None else c_min
    c_max = global_max if c_max is None else c_max

    fig = go.Figure(
        data=[
            go.Heatmap(
                z=scores_array[0],
                x=x_labels,
                y=y_labels,
                zmin=c_min,
                zmax=c_max,
                zsmooth=zsmooth,
                colorbar={&#34;title&#34;: &#34;Average Likelihood Ratio Score&#34;},
            )
        ],
        layout=go.Layout(
            title=&#34;{} to {}&#34;.format(t_min_labels[0], t_max_labels[0]),
            width=800,
            height=500,
            updatemenus=[
                dict(
                    type=&#34;buttons&#34;,
                    buttons=[
                        dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                        dict(
                            label=&#34;Pause&#34;,
                            method=&#34;animate&#34;,
                            args=[
                                None,
                                {
                                    &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                    &#34;mode&#34;: &#34;immediate&#34;,
                                    &#34;transition&#34;: {&#34;duration&#34;: 0},
                                },
                            ],
                        ),
                    ],
                )
            ],
        ),
        frames=[
            go.Frame(
                data=[go.Heatmap(z=scores_array[i], zmin=c_min, zmax=c_max)],
                layout=go.Layout(
                    title=&#34;{} to {}&#34;.format(t_min_labels[i], t_max_labels[i])
                ),
            )
            for i in range(0, len(t_min_labels))
        ],
    )
    fig.update_layout(
        xaxis_title=&#34;Longitude&#34;, yaxis_title=&#34;Latitude&#34;,
    )
    fig.show()
    return {&#34;max&#34;: c_max, &#34;min&#34;: c_min}</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SpatialScan.results.MapboxPlot"><code class="flex name class">
<span>class <span class="ident">MapboxPlot</span></span>
<span>(</span><span>database_df, london_gpd, borough='all')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MapboxPlot:
    def __init__(self, database_df, london_gpd, borough=&#39;all&#39;):
        self.database_df = database_df
        self.london_gpd = london_gpd
        self.borough = borough
        # Mapbox Token
        self.token = &#34;pk.eyJ1IjoiY2hhbmNlaGF5Y29jayIsImEiOiJja2Q0d25iNjMxYTgxMnNudzUzdm9veG5xIn0.MNo8CDYOo6z_g1lWiRM3vg&#34;
        self.masked_results = None

    def _preprocess_database_results(self):
        # Add centroid
        self.database_df[&#34;lon&#34;] = (
            self.database_df[&#34;x_min&#34;] + self.database_df[&#34;x_max&#34;]
        ) / 2
        self.database_df[&#34;lat&#34;] = (
            self.database_df[&#34;y_min&#34;] + self.database_df[&#34;y_max&#34;]
        ) / 2

        # Shapely formatting
        self.database_df[&#34;location&#34;] = self.database_df.apply(
            lambda x: Point(x.lon, x.lat), axis=1
        )

        # Project the london boroughs to standard
        self.london_gpd = self.london_gpd.to_crs(epsg=4326)

        if self.borough in [&#39;All&#39;, &#39;all&#39;, &#39;London&#39;, &#39;london&#39;]:
            boundary = gpd.GeoSeries(unary_union(self.london_gpd.geometry))
        else:
            boundary = self.london_gpd[self.london_gpd[&#39;NAME&#39;] == self.borough]

        # Does all time steps at the mo - inefficient
        self.database_df[&#34;in_borough&#34;] = self.database_df.apply(
            lambda x: boundary.contains(x.location), axis=1
        )

        self.masked_results = self.database_df[self.database_df[&#34;in_borough&#34;]]

    def display(self, metric, zmin=None, zmax=None):
        if not isinstance(self.masked_results, pd.DataFrame):
            self._preprocess_database_results()

        unique_times = self.masked_results.drop_duplicates(
            subset=[&#34;start_time_utc&#34;, &#34;end_time_utc&#34;]
        )

        t_min_ticks = unique_times[&#34;start_time_utc&#34;]
        t_max_ticks = unique_times[&#34;end_time_utc&#34;]
        t_min_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_min_ticks]
        t_max_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_max_ticks]

        global_min = self.masked_results[metric].min()
        global_max = self.masked_results[metric].max()

        zmin = global_min if zmin is None else zmin
        zmax = global_max if zmax is None else zmax

        start_time = unique_times[&#34;start_time_utc&#34;].min()

        fig = go.Figure(
            data=go.Densitymapbox(
                lon=self.masked_results[
                    self.masked_results[&#34;start_time_utc&#34;] == start_time
                ][&#34;lon&#34;],
                lat=self.masked_results[
                    self.masked_results[&#34;start_time_utc&#34;] == start_time
                ][&#34;lat&#34;],
                z=self.masked_results[
                    self.masked_results[&#34;start_time_utc&#34;] == start_time
                ][metric],
                colorscale=&#34;viridis&#34;,
                radius=100,
                opacity=0.5,
                showscale=True,
                zmin=global_min,
                zmax=global_max,
                colorbar={
                    &#34;tickcolor&#34;: &#34;white&#34;,
                    &#34;tickfont&#34;: {&#34;color&#34;: &#34;white&#34;},
                    &#34;title&#34;: {&#34;text&#34;: &#34;Score&#34;, &#34;font&#34;: {&#34;color&#34;: &#34;white&#34;}},
                },
            ),
            layout=go.Layout(
                title=&#34;{} to {}&#34;.format(t_min_labels[0], t_max_labels[0]),
                updatemenus=[
                    dict(
                        type=&#34;buttons&#34;,
                        buttons=[
                            dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                            dict(
                                label=&#34;Pause&#34;,
                                method=&#34;animate&#34;,
                                args=[
                                    None,
                                    {
                                        &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                        &#34;mode&#34;: &#34;immediate&#34;,
                                        &#34;transition&#34;: {&#34;duration&#34;: 0},
                                    },
                                ],
                            ),
                        ],
                    ),
                ],
            ),
            frames=[
                go.Frame(
                    data=[
                        go.Densitymapbox(
                            lon=self.masked_results[
                                self.masked_results[&#34;start_time_utc&#34;]
                                == start_time + np.timedelta64(i, &#34;h&#34;)
                            ][&#34;lon&#34;],
                            lat=self.masked_results[
                                self.masked_results[&#34;start_time_utc&#34;]
                                == start_time + np.timedelta64(i, &#34;h&#34;)
                            ][&#34;lat&#34;],
                            z=self.masked_results[
                                self.masked_results[&#34;start_time_utc&#34;]
                                == start_time + np.timedelta64(i, &#34;h&#34;)
                            ][metric],
                        )
                    ],
                    layout=go.Layout(
                        title=&#34;{} to {}&#34;.format(t_min_labels[i], t_max_labels[i])
                    ),
                )
                for i in range(0, len(t_min_labels))
            ],
        )
        fig.update_layout(
            mapbox_style=&#34;dark&#34;,
            mapbox_accesstoken=self.token,
            margin={&#34;l&#34;: 0, &#34;r&#34;: 0, &#34;b&#34;: 0, &#34;t&#34;: 60},
            mapbox={&#34;center&#34;: {&#34;lon&#34;: -0.09, &#34;lat&#34;: 51.495}, &#34;zoom&#34;: 9.7},
            autosize=False,
            width=1600,
            height=900,
            paper_bgcolor=&#34;rgba(0,0,0,0)&#34;,
            plot_bgcolor=&#34;rgba(0,0,0,0)&#34;,
            # paper_bgcolor=&#39;black&#39;,
            title_font_color=&#34;white&#34;,
        )
        fig.show()
        return {&#34;max&#34;: zmax, &#34;min&#34;: zmin}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="SpatialScan.results.MapboxPlot.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, metric, zmin=None, zmax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self, metric, zmin=None, zmax=None):
    if not isinstance(self.masked_results, pd.DataFrame):
        self._preprocess_database_results()

    unique_times = self.masked_results.drop_duplicates(
        subset=[&#34;start_time_utc&#34;, &#34;end_time_utc&#34;]
    )

    t_min_ticks = unique_times[&#34;start_time_utc&#34;]
    t_max_ticks = unique_times[&#34;end_time_utc&#34;]
    t_min_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_min_ticks]
    t_max_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_max_ticks]

    global_min = self.masked_results[metric].min()
    global_max = self.masked_results[metric].max()

    zmin = global_min if zmin is None else zmin
    zmax = global_max if zmax is None else zmax

    start_time = unique_times[&#34;start_time_utc&#34;].min()

    fig = go.Figure(
        data=go.Densitymapbox(
            lon=self.masked_results[
                self.masked_results[&#34;start_time_utc&#34;] == start_time
            ][&#34;lon&#34;],
            lat=self.masked_results[
                self.masked_results[&#34;start_time_utc&#34;] == start_time
            ][&#34;lat&#34;],
            z=self.masked_results[
                self.masked_results[&#34;start_time_utc&#34;] == start_time
            ][metric],
            colorscale=&#34;viridis&#34;,
            radius=100,
            opacity=0.5,
            showscale=True,
            zmin=global_min,
            zmax=global_max,
            colorbar={
                &#34;tickcolor&#34;: &#34;white&#34;,
                &#34;tickfont&#34;: {&#34;color&#34;: &#34;white&#34;},
                &#34;title&#34;: {&#34;text&#34;: &#34;Score&#34;, &#34;font&#34;: {&#34;color&#34;: &#34;white&#34;}},
            },
        ),
        layout=go.Layout(
            title=&#34;{} to {}&#34;.format(t_min_labels[0], t_max_labels[0]),
            updatemenus=[
                dict(
                    type=&#34;buttons&#34;,
                    buttons=[
                        dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                        dict(
                            label=&#34;Pause&#34;,
                            method=&#34;animate&#34;,
                            args=[
                                None,
                                {
                                    &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                    &#34;mode&#34;: &#34;immediate&#34;,
                                    &#34;transition&#34;: {&#34;duration&#34;: 0},
                                },
                            ],
                        ),
                    ],
                ),
            ],
        ),
        frames=[
            go.Frame(
                data=[
                    go.Densitymapbox(
                        lon=self.masked_results[
                            self.masked_results[&#34;start_time_utc&#34;]
                            == start_time + np.timedelta64(i, &#34;h&#34;)
                        ][&#34;lon&#34;],
                        lat=self.masked_results[
                            self.masked_results[&#34;start_time_utc&#34;]
                            == start_time + np.timedelta64(i, &#34;h&#34;)
                        ][&#34;lat&#34;],
                        z=self.masked_results[
                            self.masked_results[&#34;start_time_utc&#34;]
                            == start_time + np.timedelta64(i, &#34;h&#34;)
                        ][metric],
                    )
                ],
                layout=go.Layout(
                    title=&#34;{} to {}&#34;.format(t_min_labels[i], t_max_labels[i])
                ),
            )
            for i in range(0, len(t_min_labels))
        ],
    )
    fig.update_layout(
        mapbox_style=&#34;dark&#34;,
        mapbox_accesstoken=self.token,
        margin={&#34;l&#34;: 0, &#34;r&#34;: 0, &#34;b&#34;: 0, &#34;t&#34;: 60},
        mapbox={&#34;center&#34;: {&#34;lon&#34;: -0.09, &#34;lat&#34;: 51.495}, &#34;zoom&#34;: 9.7},
        autosize=False,
        width=1600,
        height=900,
        paper_bgcolor=&#34;rgba(0,0,0,0)&#34;,
        plot_bgcolor=&#34;rgba(0,0,0,0)&#34;,
        # paper_bgcolor=&#39;black&#39;,
        title_font_color=&#34;white&#34;,
    )
    fig.show()
    return {&#34;max&#34;: zmax, &#34;min&#34;: zmin}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="SpatialScan" href="index.html">SpatialScan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="SpatialScan.results.database_results" href="#SpatialScan.results.database_results">database_results</a></code></li>
<li><code><a title="SpatialScan.results.title_generator" href="#SpatialScan.results.title_generator">title_generator</a></code></li>
<li><code><a title="SpatialScan.results.visualise_results" href="#SpatialScan.results.visualise_results">visualise_results</a></code></li>
<li><code><a title="SpatialScan.results.visualise_results_from_database" href="#SpatialScan.results.visualise_results_from_database">visualise_results_from_database</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SpatialScan.results.MapboxPlot" href="#SpatialScan.results.MapboxPlot">MapboxPlot</a></code></h4>
<ul class="">
<li><code><a title="SpatialScan.results.MapboxPlot.display" href="#SpatialScan.results.MapboxPlot.display">display</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>