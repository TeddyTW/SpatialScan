<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>SpatialScan.results API documentation</title>
<meta name="description" content="Module to contain all functionality required to display results from the
main Expectation-Based Scan Statistic Loop" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SpatialScan.results</code></h1>
</header>
<section id="section-intro">
<p>Module to contain all functionality required to display results from the
main Expectation-Based Scan Statistic Loop</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module to contain all functionality required to display results from the
main Expectation-Based Scan Statistic Loop&#34;&#34;&#34;

import plotly.graph_objects as go
import pandas as pd
import numpy as np


def title_generator(scan_type: str, i: int, t_labels: np.ndarray) -&gt; str:
    &#34;&#34;&#34;Quick utility function to create labels based on the tye of search.
    Accounts for the varying/non-varying t_min in both regimes.
    Args:
        scan_type: &#34;Normal&#34; or &#34;Exhaustive&#34;
        i: loop iteration
        t_labels: Array of t_tick labels for plotting
    Returns:
        String representing the appropiate label for graph.
    &#34;&#34;&#34;
    if scan_type == &#34;normal&#34;:
        return &#34;{} to {}&#34;.format(t_labels[0], t_labels[i + 1])
    elif scan_type == &#34;exhaustive&#34;:
        return &#34;{} to {}&#34;.format(t_labels[i], t_labels[i + 1])
    return None


def visualise_results(
    res_df,
    metric: str = &#34;l_score_basic&#34;,
    smooth: bool = False,
    c_min: float = None,
    c_max: float = None,
) -&gt; None:
    &#34;&#34;&#34;Functionality which plots the animated results of the Spatial Scan.

    Args:
        res_df: resulting dataframe from `EBP()`
        metric: Which metric to plot from res_df
        smooth: Boolean which decides whether to smooth the spatial region in
                the animation or not.
        c_min: Minimum value to set the color bar
        c_max: Maximum value to set the color bar.
    &#34;&#34;&#34;
    assert (set([metric])) &lt;= set(res_df.columns)

    # What type of scan was it? Normal or Exhaustive?
    # Only way to tell is by the number of unuique t_mins in res_df
    num_t_mins = len(res_df[&#34;t_min&#34;].unique())

    # If more than one t_min, scan was exhaustive
    if num_t_mins &gt; 1:
        scan_type = &#34;exhaustive&#34;
    else:
        scan_type = &#34;normal&#34;

    # Infer grid partition form the resulting dataframe
    grid_partition = len(res_df[&#34;x_min&#34;].unique())

    # Infer Spatial Grid extent from resulting dataframe
    x_min = res_df[&#34;x_min&#34;].min()
    x_max = res_df[&#34;x_max&#34;].max()
    y_min = res_df[&#34;y_min&#34;].min()
    y_max = res_df[&#34;y_max&#34;].max()
    t_min = res_df[&#34;t_min&#34;].min()
    t_max = res_df[&#34;t_max&#34;].max()

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)
    t_ticks = pd.date_range(start=t_min, end=t_max, freq=&#34;H&#34;)

    # Use these to explicitly return labels
    x_labels = [
        &#34;{0:.3f}&#34;.format((x_ticks[i] + x_ticks[i + 1]) / 2)
        for i in range(len(x_ticks) - 1)
    ]
    y_labels = [
        &#34;{0:.3f}&#34;.format((y_ticks[i] + y_ticks[i + 1]) / 2)
        for i in reversed(range(len(y_ticks) - 1))
    ]

    t_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_ticks]

    # Find array of ordered dates over prediction period and format pretty for
    # plot.
    res_df = res_df.sort_values(by=[&#34;t_max&#34;])

    scores_array = []
    global_max = -np.inf
    global_min = np.inf
    for t in range(len(t_ticks) - 1):
        x_array = []
        for j in range(len(y_ticks) - 1):
            y_array = []
            for i in range(len(x_ticks) - 1):

                sub_df = res_df[
                    (res_df[&#34;x_min&#34;] &lt;= x_ticks[i])
                    &amp; (res_df[&#34;x_max&#34;] &gt;= x_ticks[i + 1])
                    &amp; (res_df[&#34;y_min&#34;] &lt;= y_ticks[j])
                    &amp; (res_df[&#34;y_max&#34;] &gt;= y_ticks[j + 1])
                    &amp; (res_df[&#34;t_min&#34;] == t_ticks[0 if scan_type == &#34;normal&#34; else t])
                    &amp; (res_df[&#34;t_max&#34;] == t_ticks[t + 1])
                ]

                l_score = sub_df[metric].mean()

                if l_score &gt; global_max:
                    global_max = l_score
                if l_score &lt; global_min:
                    global_min = l_score

                y_array.append(l_score)
            x_array.insert(0, y_array)
        scores_array.append(x_array)

    zsmooth = &#34;best&#34; if smooth else None
    c_min = global_min if c_min is None else c_min
    c_max = global_max if c_max is None else c_max

    fig = go.Figure(
        data=[
            go.Heatmap(
                z=scores_array[0],
                x=x_labels,
                y=y_labels,
                zmin=c_min,
                zmax=c_max,
                zsmooth=zsmooth,
                colorbar={&#34;title&#34;: &#34;Average Likelihood Ratio Score&#34;},
            )
        ],
        layout=go.Layout(
            title=&#34;{} to {}&#34;.format(t_labels[0], t_labels[1]),
            width=800,
            height=500,
            updatemenus=[
                dict(
                    type=&#34;buttons&#34;,
                    buttons=[
                        dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                        dict(
                            label=&#34;Pause&#34;,
                            method=&#34;animate&#34;,
                            args=[
                                None,
                                {
                                    &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                    &#34;mode&#34;: &#34;immediate&#34;,
                                    &#34;transition&#34;: {&#34;duration&#34;: 0},
                                },
                            ],
                        ),
                    ],
                )
            ],
        ),
        frames=[
            go.Frame(
                data=[go.Heatmap(z=scores_array[i], zmin=c_min, zmax=c_max)],
                layout=go.Layout(title=title_generator(scan_type, i, t_labels)),
            )
            for i in range(0, len(t_labels) - 1)
        ],
    )
    fig.update_layout(
        xaxis_title=&#34;Longitude&#34;, yaxis_title=&#34;Latitude&#34;,
    )
    fig.show()
    return {&#34;max&#34;: c_max, &#34;min&#34;: c_min}


def database_results(res_df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Functionality to produce a dataframe in the correct format for storage
    in the database. It may not be what we want perfectly atm, but template
    functionality is in place. Calculates the average likelihood per grid cell.
    Beware: this means different things depending on which function (`EBP()` or
    `EBP_exhaustive()`) was called.

    Args:
        res_df: Resulting dataframe from `EBP()` OR `EBP_exhaustive()`
    Returns:
        pd.DataFrame in format for storage.
    &#34;&#34;&#34;

    # What type of scan was it? Normal or Exhaustive?
    # Only way to tell is by the number of unuique t_mins in res_df
    num_t_mins = len(res_df[&#34;t_min&#34;].unique())

    # If more than one t_min, scan was exhaustive
    if num_t_mins &gt; 1:
        scan_type = &#34;exhaustive&#34;
    else:
        scan_type = &#34;normal&#34;

    # Infer grid partition form the resulting dataframe
    grid_partition = len(res_df[&#34;x_min&#34;].unique())

    # Infer Spatial Grid extent from resulting dataframe
    x_min = res_df[&#34;x_min&#34;].min()
    x_max = res_df[&#34;x_max&#34;].max()
    y_min = res_df[&#34;y_min&#34;].min()
    y_max = res_df[&#34;y_max&#34;].max()
    t_min = res_df[&#34;t_min&#34;].min()
    t_max = res_df[&#34;t_max&#34;].max()

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)
    t_ticks = pd.date_range(start=t_min, end=t_max, freq=&#34;H&#34;)

    return_dict = {}
    num_regions = 0
    for t in range(len(t_ticks) - 1):
        num_spatial_regions = 0
        for j in range(len(y_ticks) - 1):
            for i in range(len(x_ticks) - 1):

                sub_df = res_df[
                    (res_df[&#34;x_min&#34;] &lt;= x_ticks[i])
                    &amp; (res_df[&#34;x_max&#34;] &gt;= x_ticks[i + 1])
                    &amp; (res_df[&#34;y_min&#34;] &lt;= y_ticks[j])
                    &amp; (res_df[&#34;y_max&#34;] &gt;= y_ticks[j + 1])
                    &amp; (res_df[&#34;t_min&#34;] == t_ticks[0 if scan_type == &#34;normal&#34; else t])
                    &amp; (res_df[&#34;t_max&#34;] == t_ticks[t + 1])
                ]

                B, C = sub_df[[&#34;B_in&#34;, &#34;C_in&#34;]].sum()

                means = sub_df[
                    [
                        &#34;l_score_basic&#34;,
                        &#34;l_score_000&#34;,
                        &#34;l_score_025&#34;,
                        &#34;l_score_050&#34;,
                        &#34;l_score_075&#34;,
                        &#34;l_score_100&#34;,
                    ]
                ].mean()

                return_dict[num_regions] = {
                    &#34;start_time_utc&#34;: t_ticks[0 if scan_type == &#34;normal&#34; else t],
                    &#34;end_time_utc&#34;: t_ticks[t + 1],
                    &#34;point_id&#34;: num_spatial_regions,
                    &#34;observed_count&#34;: C,
                    &#34;forecasted_count&#34;: B,
                    &#34;av_lhd_score_basic&#34;: means[&#34;l_score_basic&#34;],
                    &#34;av_lhd_score_eps_000&#34;: means[&#34;l_score_000&#34;],
                    &#34;av_lhd_score_eps_025&#34;: means[&#34;l_score_025&#34;],
                    &#34;av_lhd_score_eps_050&#34;: means[&#34;l_score_050&#34;],
                    &#34;av_lhd_score_eps_075&#34;: means[&#34;l_score_075&#34;],
                    &#34;av_lhd_score_eps_100&#34;: means[&#34;l_score_100&#34;],
                }

                num_spatial_regions += 1
                num_regions += 1
    return pd.DataFrame.from_dict(return_dict, &#34;index&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="SpatialScan.results.database_results"><code class="name flex">
<span>def <span class="ident">database_results</span></span>(<span>res_df: pandas.core.frame.DataFrame) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Functionality to produce a dataframe in the correct format for storage
in the database. It may not be what we want perfectly atm, but template
functionality is in place. Calculates the average likelihood per grid cell.
Beware: this means different things depending on which function (<code>EBP()</code> or
<code>EBP_exhaustive()</code>) was called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>res_df</code></strong></dt>
<dd>Resulting dataframe from <code>EBP()</code> OR <code>EBP_exhaustive()</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pd.DataFrame in format for storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def database_results(res_df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Functionality to produce a dataframe in the correct format for storage
    in the database. It may not be what we want perfectly atm, but template
    functionality is in place. Calculates the average likelihood per grid cell.
    Beware: this means different things depending on which function (`EBP()` or
    `EBP_exhaustive()`) was called.

    Args:
        res_df: Resulting dataframe from `EBP()` OR `EBP_exhaustive()`
    Returns:
        pd.DataFrame in format for storage.
    &#34;&#34;&#34;

    # What type of scan was it? Normal or Exhaustive?
    # Only way to tell is by the number of unuique t_mins in res_df
    num_t_mins = len(res_df[&#34;t_min&#34;].unique())

    # If more than one t_min, scan was exhaustive
    if num_t_mins &gt; 1:
        scan_type = &#34;exhaustive&#34;
    else:
        scan_type = &#34;normal&#34;

    # Infer grid partition form the resulting dataframe
    grid_partition = len(res_df[&#34;x_min&#34;].unique())

    # Infer Spatial Grid extent from resulting dataframe
    x_min = res_df[&#34;x_min&#34;].min()
    x_max = res_df[&#34;x_max&#34;].max()
    y_min = res_df[&#34;y_min&#34;].min()
    y_max = res_df[&#34;y_max&#34;].max()
    t_min = res_df[&#34;t_min&#34;].min()
    t_max = res_df[&#34;t_max&#34;].max()

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)
    t_ticks = pd.date_range(start=t_min, end=t_max, freq=&#34;H&#34;)

    return_dict = {}
    num_regions = 0
    for t in range(len(t_ticks) - 1):
        num_spatial_regions = 0
        for j in range(len(y_ticks) - 1):
            for i in range(len(x_ticks) - 1):

                sub_df = res_df[
                    (res_df[&#34;x_min&#34;] &lt;= x_ticks[i])
                    &amp; (res_df[&#34;x_max&#34;] &gt;= x_ticks[i + 1])
                    &amp; (res_df[&#34;y_min&#34;] &lt;= y_ticks[j])
                    &amp; (res_df[&#34;y_max&#34;] &gt;= y_ticks[j + 1])
                    &amp; (res_df[&#34;t_min&#34;] == t_ticks[0 if scan_type == &#34;normal&#34; else t])
                    &amp; (res_df[&#34;t_max&#34;] == t_ticks[t + 1])
                ]

                B, C = sub_df[[&#34;B_in&#34;, &#34;C_in&#34;]].sum()

                means = sub_df[
                    [
                        &#34;l_score_basic&#34;,
                        &#34;l_score_000&#34;,
                        &#34;l_score_025&#34;,
                        &#34;l_score_050&#34;,
                        &#34;l_score_075&#34;,
                        &#34;l_score_100&#34;,
                    ]
                ].mean()

                return_dict[num_regions] = {
                    &#34;start_time_utc&#34;: t_ticks[0 if scan_type == &#34;normal&#34; else t],
                    &#34;end_time_utc&#34;: t_ticks[t + 1],
                    &#34;point_id&#34;: num_spatial_regions,
                    &#34;observed_count&#34;: C,
                    &#34;forecasted_count&#34;: B,
                    &#34;av_lhd_score_basic&#34;: means[&#34;l_score_basic&#34;],
                    &#34;av_lhd_score_eps_000&#34;: means[&#34;l_score_000&#34;],
                    &#34;av_lhd_score_eps_025&#34;: means[&#34;l_score_025&#34;],
                    &#34;av_lhd_score_eps_050&#34;: means[&#34;l_score_050&#34;],
                    &#34;av_lhd_score_eps_075&#34;: means[&#34;l_score_075&#34;],
                    &#34;av_lhd_score_eps_100&#34;: means[&#34;l_score_100&#34;],
                }

                num_spatial_regions += 1
                num_regions += 1
    return pd.DataFrame.from_dict(return_dict, &#34;index&#34;)</code></pre>
</details>
</dd>
<dt id="SpatialScan.results.title_generator"><code class="name flex">
<span>def <span class="ident">title_generator</span></span>(<span>scan_type: str, i: int, t_labels: numpy.ndarray) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Quick utility function to create labels based on the tye of search.
Accounts for the varying/non-varying t_min in both regimes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scan_type</code></strong></dt>
<dd>"Normal" or "Exhaustive"</dd>
<dt><strong><code>i</code></strong></dt>
<dd>loop iteration</dd>
<dt><strong><code>t_labels</code></strong></dt>
<dd>Array of t_tick labels for plotting</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String representing the appropiate label for graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title_generator(scan_type: str, i: int, t_labels: np.ndarray) -&gt; str:
    &#34;&#34;&#34;Quick utility function to create labels based on the tye of search.
    Accounts for the varying/non-varying t_min in both regimes.
    Args:
        scan_type: &#34;Normal&#34; or &#34;Exhaustive&#34;
        i: loop iteration
        t_labels: Array of t_tick labels for plotting
    Returns:
        String representing the appropiate label for graph.
    &#34;&#34;&#34;
    if scan_type == &#34;normal&#34;:
        return &#34;{} to {}&#34;.format(t_labels[0], t_labels[i + 1])
    elif scan_type == &#34;exhaustive&#34;:
        return &#34;{} to {}&#34;.format(t_labels[i], t_labels[i + 1])
    return None</code></pre>
</details>
</dd>
<dt id="SpatialScan.results.visualise_results"><code class="name flex">
<span>def <span class="ident">visualise_results</span></span>(<span>res_df, metric: str = 'l_score_basic', smooth: bool = False, c_min: float = None, c_max: float = None) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Functionality which plots the animated results of the Spatial Scan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>res_df</code></strong></dt>
<dd>resulting dataframe from <code>EBP()</code></dd>
<dt><strong><code>metric</code></strong></dt>
<dd>Which metric to plot from res_df</dd>
<dt><strong><code>smooth</code></strong></dt>
<dd>Boolean which decides whether to smooth the spatial region in
the animation or not.</dd>
<dt><strong><code>c_min</code></strong></dt>
<dd>Minimum value to set the color bar</dd>
<dt><strong><code>c_max</code></strong></dt>
<dd>Maximum value to set the color bar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualise_results(
    res_df,
    metric: str = &#34;l_score_basic&#34;,
    smooth: bool = False,
    c_min: float = None,
    c_max: float = None,
) -&gt; None:
    &#34;&#34;&#34;Functionality which plots the animated results of the Spatial Scan.

    Args:
        res_df: resulting dataframe from `EBP()`
        metric: Which metric to plot from res_df
        smooth: Boolean which decides whether to smooth the spatial region in
                the animation or not.
        c_min: Minimum value to set the color bar
        c_max: Maximum value to set the color bar.
    &#34;&#34;&#34;
    assert (set([metric])) &lt;= set(res_df.columns)

    # What type of scan was it? Normal or Exhaustive?
    # Only way to tell is by the number of unuique t_mins in res_df
    num_t_mins = len(res_df[&#34;t_min&#34;].unique())

    # If more than one t_min, scan was exhaustive
    if num_t_mins &gt; 1:
        scan_type = &#34;exhaustive&#34;
    else:
        scan_type = &#34;normal&#34;

    # Infer grid partition form the resulting dataframe
    grid_partition = len(res_df[&#34;x_min&#34;].unique())

    # Infer Spatial Grid extent from resulting dataframe
    x_min = res_df[&#34;x_min&#34;].min()
    x_max = res_df[&#34;x_max&#34;].max()
    y_min = res_df[&#34;y_min&#34;].min()
    y_max = res_df[&#34;y_max&#34;].max()
    t_min = res_df[&#34;t_min&#34;].min()
    t_max = res_df[&#34;t_max&#34;].max()

    # Re-create the grid used
    x_ticks = np.linspace(x_min, x_max, grid_partition + 1)
    y_ticks = np.linspace(y_min, y_max, grid_partition + 1)
    t_ticks = pd.date_range(start=t_min, end=t_max, freq=&#34;H&#34;)

    # Use these to explicitly return labels
    x_labels = [
        &#34;{0:.3f}&#34;.format((x_ticks[i] + x_ticks[i + 1]) / 2)
        for i in range(len(x_ticks) - 1)
    ]
    y_labels = [
        &#34;{0:.3f}&#34;.format((y_ticks[i] + y_ticks[i + 1]) / 2)
        for i in reversed(range(len(y_ticks) - 1))
    ]

    t_labels = [x.strftime(&#34;%I%p, %d %b %y&#34;) for x in t_ticks]

    # Find array of ordered dates over prediction period and format pretty for
    # plot.
    res_df = res_df.sort_values(by=[&#34;t_max&#34;])

    scores_array = []
    global_max = -np.inf
    global_min = np.inf
    for t in range(len(t_ticks) - 1):
        x_array = []
        for j in range(len(y_ticks) - 1):
            y_array = []
            for i in range(len(x_ticks) - 1):

                sub_df = res_df[
                    (res_df[&#34;x_min&#34;] &lt;= x_ticks[i])
                    &amp; (res_df[&#34;x_max&#34;] &gt;= x_ticks[i + 1])
                    &amp; (res_df[&#34;y_min&#34;] &lt;= y_ticks[j])
                    &amp; (res_df[&#34;y_max&#34;] &gt;= y_ticks[j + 1])
                    &amp; (res_df[&#34;t_min&#34;] == t_ticks[0 if scan_type == &#34;normal&#34; else t])
                    &amp; (res_df[&#34;t_max&#34;] == t_ticks[t + 1])
                ]

                l_score = sub_df[metric].mean()

                if l_score &gt; global_max:
                    global_max = l_score
                if l_score &lt; global_min:
                    global_min = l_score

                y_array.append(l_score)
            x_array.insert(0, y_array)
        scores_array.append(x_array)

    zsmooth = &#34;best&#34; if smooth else None
    c_min = global_min if c_min is None else c_min
    c_max = global_max if c_max is None else c_max

    fig = go.Figure(
        data=[
            go.Heatmap(
                z=scores_array[0],
                x=x_labels,
                y=y_labels,
                zmin=c_min,
                zmax=c_max,
                zsmooth=zsmooth,
                colorbar={&#34;title&#34;: &#34;Average Likelihood Ratio Score&#34;},
            )
        ],
        layout=go.Layout(
            title=&#34;{} to {}&#34;.format(t_labels[0], t_labels[1]),
            width=800,
            height=500,
            updatemenus=[
                dict(
                    type=&#34;buttons&#34;,
                    buttons=[
                        dict(label=&#34;Play&#34;, method=&#34;animate&#34;, args=[None]),
                        dict(
                            label=&#34;Pause&#34;,
                            method=&#34;animate&#34;,
                            args=[
                                None,
                                {
                                    &#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: False},
                                    &#34;mode&#34;: &#34;immediate&#34;,
                                    &#34;transition&#34;: {&#34;duration&#34;: 0},
                                },
                            ],
                        ),
                    ],
                )
            ],
        ),
        frames=[
            go.Frame(
                data=[go.Heatmap(z=scores_array[i], zmin=c_min, zmax=c_max)],
                layout=go.Layout(title=title_generator(scan_type, i, t_labels)),
            )
            for i in range(0, len(t_labels) - 1)
        ],
    )
    fig.update_layout(
        xaxis_title=&#34;Longitude&#34;, yaxis_title=&#34;Latitude&#34;,
    )
    fig.show()
    return {&#34;max&#34;: c_max, &#34;min&#34;: c_min}</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="SpatialScan" href="index.html">SpatialScan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="SpatialScan.results.database_results" href="#SpatialScan.results.database_results">database_results</a></code></li>
<li><code><a title="SpatialScan.results.title_generator" href="#SpatialScan.results.title_generator">title_generator</a></code></li>
<li><code><a title="SpatialScan.results.visualise_results" href="#SpatialScan.results.visualise_results">visualise_results</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>